<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Realtime Order Book Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap');
        
        :root {
            --bg-primary: #0a0a0b;
            --bg-secondary: #111113;
            --bg-elevated: #1f1f23;
            --bg-hover: #27272a;
            --accent-primary: #22d3ee;
            --accent-blue: #3b82f6;
            --accent-emerald: #10b981;
            --accent-emerald-bright: #34d399;
            --color-danger: #ef4444;
            --color-danger-bright: #f87171;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-default: rgba(255, 255, 255, 0.1);
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: transparent;
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .orderbook-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
        }

        #range-select {
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            padding: 8px 16px;
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
        }

        #range-select:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        #range-select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.15);
        }

        #range-select option {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        #chart {
            margin: 0;
            padding: 24px;
            width: 100%;
            height: calc(100% - 60px);
            min-height: 400px;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* D3 Chart Styling - Vibrant and Alive */
        .line {
            fill: none;
            stroke-width: 3px;
            transition: stroke-width 0.2s ease;
        }

        .bid-line {
            stroke: var(--accent-emerald);
            filter: drop-shadow(0 0 4px rgba(16, 185, 129, 0.6)) 
                    drop-shadow(0 0 8px rgba(52, 211, 153, 0.3));
        }

        .ask-line {
            stroke: var(--color-danger);
            filter: drop-shadow(0 0 4px rgba(239, 68, 68, 0.6)) 
                    drop-shadow(0 0 8px rgba(248, 113, 113, 0.3));
        }

        .area {
            transition: opacity 0.3s ease;
        }

        .bid-area {
            fill: url(#bidGradient);
            opacity: 0.35;
        }

        .ask-area {
            fill: url(#askGradient);
            opacity: 0.35;
        }
        
        /* Gradient definitions for vibrant colors */
        .gradient-defs {
            position: absolute;
            width: 0;
            height: 0;
        }

        /* Axis styling - Enhanced with colors */
        .orderbook-axis {
            color: var(--text-muted);
        }

        .orderbook-axis text {
            fill: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .orderbook-axis.x-axis text {
            fill: var(--accent-primary);
            opacity: 0.8;
        }

        .orderbook-axis.y-axis text {
            fill: var(--accent-blue);
            opacity: 0.9;
        }

        .orderbook-axis path,
        .orderbook-axis line {
            stroke: var(--border-subtle);
            stroke-width: 1;
        }

        .orderbook-axis .domain {
            stroke: var(--accent-primary);
            stroke-width: 2;
            opacity: 0.4;
        }

        .orderbook-axis .tick line {
            stroke: var(--accent-primary);
            opacity: 0.2;
        }

        .orderbook-axis.x-axis .tick line {
            stroke: var(--accent-primary);
            opacity: 0.15;
        }

        .orderbook-axis.y-axis .tick line {
            stroke: var(--accent-blue);
            opacity: 0.15;
        }
        
        /* Mid-price line styling */
        .mid-price-line {
            pointer-events: none;
        }
        
        /* Grid lines */
        .grid-lines .grid-line {
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="orderbook-controls">
        <select id="range-select" value="0.01">
            <option value="0.002">20 bps</option>
            <option value="0.004">40 bps</option>
            <option value="0.006">60 bps</option>
            <option value="0.008">80 bps</option>
            <option value="0.01" selected>100 bps (1%)</option>
            <option value="0.02">200 bps (2%)</option>
            <option value="0.03">300 bps (3%)</option>
            <option value="0.05">5%</option>
            <option value="0.1">10%</option>
        </select>
    </div>

    <!-- Container for the chart -->
    <div id="chart"></div>

    <!-- Include the script -->
    <script>

        // Set up SVG dimensions and margins - make responsive
        // Increased left margin to prevent y-axis labels from being cut
        const margin = { top: 30, right: 40, bottom: 40, left: 85 };
        
        // Get container dimensions
        const chartContainer = document.getElementById('chart');
        const containerWidth = chartContainer.clientWidth || window.innerWidth - 40;
        const containerHeight = chartContainer.clientHeight || 500;
        
        const width = Math.max(containerWidth - margin.left - margin.right, 600);
        const height = Math.max(containerHeight - margin.top - margin.bottom, 400);

        // Append SVG to the chart div - make it responsive
        const svg = d3.select('#chart')
            .append('svg')
            .attr('width', '100%')
            .attr('height', height + margin.top + margin.bottom)
            .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
            .attr('preserveAspectRatio', 'none');
        
        // Add gradient definitions for vibrant colors
        const defs = svg.append('defs');
        
        // Bid gradient (green/emerald)
        const bidGradient = defs.append('linearGradient')
            .attr('id', 'bidGradient')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%');
        bidGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#34d399')
            .attr('stop-opacity', 0.5);
        bidGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#10b981')
            .attr('stop-opacity', 0.2);
        
        // Ask gradient (red)
        const askGradient = defs.append('linearGradient')
            .attr('id', 'askGradient')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%');
        askGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#f87171')
            .attr('stop-opacity', 0.5);
        askGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#ef4444')
            .attr('stop-opacity', 0.2);
        
        // Main chart group
        const chartGroup = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Store dimensions and references for updates
        let chartWidth = width;
        let chartHeight = height;
        
        // Store SVG reference globally for resize handling
        window.orderbookSvg = svg;

        // Initialize scales - will be updated with actual width
        const x = d3.scaleLinear().range([0, chartWidth]);
        const y = d3.scaleLinear().range([chartHeight, 0]);

        // Initialize axes
        const xAxis = chartGroup.append('g')
            .attr('transform', `translate(0,${chartHeight})`)
            .attr('class', 'orderbook-axis x-axis');
        const yAxis = chartGroup.append('g')
            .attr('class', 'orderbook-axis y-axis');

        // Line generators
        const bidLine = d3.line()
            .x(d => x(d.price))
            .y(d => y(d.cumVolume));

        const askLine = d3.line()
            .x(d => x(d.price))
            .y(d => y(d.cumVolume));

        // **Area generators for filling under the lines**
        const bidArea = d3.area()
            .x(d => x(d.price))
            .y0(chartHeight) // Start from the bottom (x-axis)
            .y1(d => y(d.cumVolume));

        const askArea = d3.area()
            .x(d => x(d.price))
            .y0(chartHeight)
            .y1(d => y(d.cumVolume));

        // Paths for bids and asks areas
        const bidAreaPath = chartGroup.append('path')
            .attr('class', 'area bid-area');

        const askAreaPath = chartGroup.append('path')
            .attr('class', 'area ask-area');

        // Paths for bids and asks lines (ensure these are on top of areas)
        const bidPath = chartGroup.append('path')
            .attr('class', 'line bid-line');

        const askPath = chartGroup.append('path')
            .attr('class', 'line ask-line');
        
        // Mid-price indicator line
        const midPriceLine = chartGroup.append('line')
            .attr('class', 'mid-price-line')
            .attr('stroke', 'var(--accent-primary)')
            .attr('stroke-width', 1.5)
            .attr('stroke-dasharray', '4,4')
            .attr('opacity', 0.5)
            .attr('y1', 0)
            .attr('y2', chartHeight);
        
        // Grid lines group
        const gridGroup = chartGroup.append('g')
            .attr('class', 'grid-lines');

        // Function to generate random data (simulate realtime updates)
        function generateData() {
            const midPrice = 100;
            const levels = 25;

            const bids = [];
            const asks = [];

            // Generate bids
            for (let i = levels; i > 0; i--) {
                const price = midPrice - i - Math.random();
                const volume = Math.random() * 10 + 1;
                bids.push({ price, volume });
            }

            // Generate asks
            for (let i = 1; i <= levels; i++) {
                const price = midPrice + i + Math.random();
                const volume = Math.random() * 10 + 1;
                asks.push({ price, volume });
            }

            // Sort bids descending and asks ascending
            bids.sort((a, b) => b.price - a.price);
            asks.sort((a, b) => a.price - b.price);

            // Calculate cumulative volume
            let cumVolume = 0;
            bids.forEach(d => {
                cumVolume += d.volume;
                d.cumVolume = cumVolume;
            });

            cumVolume = 0;
            asks.forEach(d => {
                cumVolume += d.volume;
                d.cumVolume = cumVolume;
            });

            return { bids, asks };
        }

        // Function to update the chart
        function update(data) {
            if (!data || !data.bids || !data.asks || data.bids.length === 0 || data.asks.length === 0) {
                console.warn('Invalid data for update:', data);
                return;
            }
            
            // Update chart dimensions if container size changed
            const newContainerWidth = chartContainer.clientWidth || window.innerWidth - 40;
            const newContainerHeight = chartContainer.clientHeight || 500;
            const newWidth = Math.max(newContainerWidth - margin.left - margin.right, 600);
            const newHeight = Math.max(newContainerHeight - margin.top - margin.bottom, 400);
            
            if (newWidth !== chartWidth || newHeight !== chartHeight) {
                chartWidth = newWidth;
                chartHeight = newHeight;
                
                // Update scales ranges
                x.range([0, chartWidth]);
                y.range([chartHeight, 0]);
                
                // Update area generators
                bidArea.y0(chartHeight);
                askArea.y0(chartHeight);
                
                // Update axes position
                xAxis.attr('transform', `translate(0,${chartHeight})`);
                
                // Update SVG viewBox
                const svgElement = d3.select('#chart svg');
                svgElement.attr('viewBox', `0 0 ${chartWidth + margin.left + margin.right} ${chartHeight + margin.top + margin.bottom}`);
            }

            // Calculate mid price from best bid and best ask
            const bestBid = data.bids[0];
            const bestAsk = data.asks[0];
            
            if (!bestBid || !bestAsk) {
                console.warn('Missing best bid or ask');
                return;
            }
            
            const midPrice = 0.5 * (bestBid.price + bestAsk.price);
            
            // Update scales with range filter
            const bpsWidth = Number(window.orderbookRange) || 0.01;
            const minPrice = (1 - bpsWidth) * midPrice;
            const maxPrice = (1 + bpsWidth) * midPrice;
            
            console.log('Price range:', {
                midPrice: midPrice.toFixed(2),
                minPrice: minPrice.toFixed(2),
                maxPrice: maxPrice.toFixed(2),
                bpsWidth,
                priceRange: ((maxPrice - minPrice) / midPrice * 100).toFixed(2) + '%',
                bidRange: data.bids.length > 0 ? [data.bids[data.bids.length - 1]?.price.toFixed(2), data.bids[0]?.price.toFixed(2)] : [],
                askRange: data.asks.length > 0 ? [data.asks[0]?.price.toFixed(2), data.asks[data.asks.length - 1]?.price.toFixed(2)] : []
            });
            
            // Filter data based on range
            // Bids: include all bids from minPrice up to and including midPrice (bids are below mid)
            const filteredBids = data.bids.filter(d => d.price >= minPrice && d.price <= midPrice);
            // Asks: include all asks from midPrice up to and including maxPrice (asks are above mid)
            const filteredAsks = data.asks.filter(d => d.price >= midPrice && d.price <= maxPrice);
            
            if (filteredBids.length === 0 || filteredAsks.length === 0) {
                console.warn('No data after filtering:', { 
                    bidCount: filteredBids.length, 
                    askCount: filteredAsks.length,
                    range: [minPrice, maxPrice],
                    midPrice,
                    totalBids: data.bids.length,
                    totalAsks: data.asks.length
                });
                return;
            }
            
            // Set x domain to show the full range
            x.domain([minPrice, maxPrice]);
            
            // Get max cumulative volume from filtered data
            // Use the last item in each filtered array (furthest from mid price)
            const lastBid = filteredBids[filteredBids.length - 1];
            const lastAsk = filteredAsks[filteredAsks.length - 1];
            const maxCumVolume = Math.max(
                lastBid ? lastBid.cumVolume : 0,
                lastAsk ? lastAsk.cumVolume : 0
            );
            
            if (maxCumVolume === 0) {
                console.warn('Zero cumulative volume');
                return;
            }
            
            y.domain([0, maxCumVolume]);

            // Update mid-price line
            const midPriceX = x(midPrice);
            midPriceLine
                .attr('x1', midPriceX)
                .attr('x2', midPriceX)
                .attr('y1', 0)
                .attr('y2', chartHeight);

            // Draw grid lines with blue accent
            gridGroup.selectAll('.grid-line').remove();
            
            // Horizontal grid lines (volume levels)
            const yTicks = y.ticks(6);
            yTicks.forEach(tick => {
                gridGroup.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', 0)
                    .attr('x2', chartWidth)
                    .attr('y1', y(tick))
                    .attr('y2', y(tick))
                    .attr('stroke', 'var(--accent-blue)')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.15)
                    .attr('stroke-dasharray', '2,4');
            });
            
            // Vertical grid lines (price levels) - fewer to avoid clutter
            const xTicks = x.ticks(8);
            xTicks.forEach(tick => {
                gridGroup.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', x(tick))
                    .attr('x2', x(tick))
                    .attr('y1', 0)
                    .attr('y2', chartHeight)
                    .attr('stroke', 'var(--accent-primary)')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.1)
                    .attr('stroke-dasharray', '2,4');
            });

            // Update axes with smooth transitions and proper formatting
            xAxis.transition()
                .duration(150)
                .ease(d3.easeCubicOut)
                .call(d3.axisBottom(x)
                    .tickFormat(d3.format(',.2f'))
                    .ticks(8));
            
            // Y-axis with better formatting and spacing to prevent cutoff
            yAxis.transition()
                .duration(150)
                .ease(d3.easeCubicOut)
                .call(d3.axisLeft(y)
                    .tickFormat(d => {
                        // Format large numbers with K, M, B suffixes
                        if (d >= 1000000000) return (d / 1000000000).toFixed(1) + 'B';
                        if (d >= 1000000) return (d / 1000000).toFixed(1) + 'M';
                        if (d >= 1000) return (d / 1000).toFixed(1) + 'K';
                        return d3.format(',.0f')(d);
                    })
                    .ticks(6));

            // Update bid area with filtered data - smooth transitions
            bidAreaPath
                .datum(filteredBids)
                .transition()
                .duration(200)
                .ease(d3.easeCubicOut)
                .attr('d', bidArea);

            // Update ask area with filtered data - smooth transitions
            askAreaPath
                .datum(filteredAsks)
                .transition()
                .duration(200)
                .ease(d3.easeCubicOut)
                .attr('d', askArea);

            // Update bid line with filtered data - smooth transitions
            bidPath
                .datum([{ price: filteredBids[0].price, cumVolume: 0 }, ...filteredBids])
                .transition()
                .duration(200)
                .ease(d3.easeCubicOut)
                .attr('d', bidLine);

            // Update ask line with filtered data - smooth transitions
            askPath
                .datum([{ price: filteredAsks[0].price, cumVolume: 0 }, ...filteredAsks])
                .transition()
                .duration(200)
                .ease(d3.easeCubicOut)
                .attr('d', askLine);
        }

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Re-trigger update with current data if available
                if (window.lastOrderbookData) {
                    update(window.lastOrderbookData);
                }
            }, 250);
        });
        
        // Initial data load - will be replaced by real data
        // let orderBookData = generateData();
        // update(orderBookData);

        // Simulate realtime updates every 3 seconds
        /*
        setInterval(() => {
            orderBookData = generateData();
            update(orderBookData);
        }, 500);
        */
        // Convert symbol format: BTC/USDT -> BTCUSDT
        function formatSymbolForBinance(displaySymbol) {
            return displaySymbol.replace('/', '').toUpperCase();
        }

        // Fetch orderbook snapshot from Binance
        async function fetchOrderbookSnapshot(symbol, limit = 5000) {
            try {
                // Use max limit (5000) to get as much orderbook data as possible
                const response = await fetch(
                    `https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=${limit}`
                );
                const data = await response.json();
                
                return {
                    bids: data.bids.map(([price, quantity]) => [
                        parseFloat(price),
                        parseFloat(quantity)
                    ]).sort((a, b) => b[0] - a[0]),
                    asks: data.asks.map(([price, quantity]) => [
                        parseFloat(price),
                        parseFloat(quantity)
                    ]).sort((a, b) => a[0] - b[0]),
                    lastUpdateId: data.lastUpdateId,
                };
            } catch (error) {
                console.error(`Error fetching orderbook snapshot for ${symbol}:`, error);
                return { bids: [], asks: [], lastUpdateId: 0 };
            }
        }

        // Create WebSocket connection for real-time orderbook depth updates
        // Note: WebSocket only provides 20 levels, but we use it to update the full snapshot
        function createOrderbookWebSocket(symbol, onOrderbookUpdate, initialSnapshot = null) {
            const ws = new WebSocket(
                `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth20@100ms`
            );
            
            // Initialize with snapshot if provided
            let orderbook = initialSnapshot 
                ? {
                    bids: initialSnapshot.bids.map(([p, q]) => [parseFloat(p), parseFloat(q)]),
                    asks: initialSnapshot.asks.map(([p, q]) => [parseFloat(p), parseFloat(q)])
                }
                : { bids: [], asks: [] };
            
            let lastUpdateId = initialSnapshot?.lastUpdateId || 0;
            let isFirstUpdate = true;
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.e === 'depthUpdate') {
                        // Skip updates before snapshot
                        if (isFirstUpdate && data.u <= lastUpdateId) {
                            return;
                        }
                        isFirstUpdate = false;
                        
                        // Update orderbook with incremental updates
                        // Process bid updates
                        if (data.b) {
                            data.b.forEach(([price, quantity]) => {
                                const priceNum = parseFloat(price);
                                const qtyNum = parseFloat(quantity);
                                
                                if (qtyNum === 0) {
                                    // Remove price level
                                    orderbook.bids = orderbook.bids.filter(b => Math.abs(b[0] - priceNum) > 0.00000001);
                                } else {
                                    // Update or add price level
                                    const existingIndex = orderbook.bids.findIndex(b => Math.abs(b[0] - priceNum) < 0.00000001);
                                    if (existingIndex >= 0) {
                                        orderbook.bids[existingIndex][1] = qtyNum;
                                    } else {
                                        orderbook.bids.push([priceNum, qtyNum]);
                                    }
                                }
                            });
                            // Sort bids descending
                            orderbook.bids.sort((a, b) => b[0] - a[0]);
                        }
                        
                        // Process ask updates
                        if (data.a) {
                            data.a.forEach(([price, quantity]) => {
                                const priceNum = parseFloat(price);
                                const qtyNum = parseFloat(quantity);
                                
                                if (qtyNum === 0) {
                                    // Remove price level
                                    orderbook.asks = orderbook.asks.filter(a => Math.abs(a[0] - priceNum) > 0.00000001);
                                } else {
                                    // Update or add price level
                                    const existingIndex = orderbook.asks.findIndex(a => Math.abs(a[0] - priceNum) < 0.00000001);
                                    if (existingIndex >= 0) {
                                        orderbook.asks[existingIndex][1] = qtyNum;
                                    } else {
                                        orderbook.asks.push([priceNum, qtyNum]);
                                    }
                                }
                            });
                            // Sort asks ascending
                            orderbook.asks.sort((a, b) => a[0] - b[0]);
                        }
                        
                        // Send updated orderbook
                        onOrderbookUpdate({
                            bids: [...orderbook.bids],
                            asks: [...orderbook.asks],
                            lastUpdateId: data.u,
                        });
                    }
                } catch (error) {
                    console.error('Error parsing orderbook WebSocket message:', error);
                }
            };
            
            ws.onerror = (error) => {
                console.error('Orderbook WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('Orderbook WebSocket closed');
            };
            
            return ws;
        }

        // Fetch trading pairs from Binance
        async function fetchTradingPairs() {
            try {
                const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const data = await response.json();
                
                // Filter for USDT pairs and sort
                const usdtPairs = data.symbols
                    .filter(s => s.symbol.endsWith('USDT') && s.status === 'TRADING')
                    .map(s => ({
                        symbol: s.symbol,
                        displaySymbol: `${s.baseAsset}/${s.quoteAsset}`,
                    }))
                    .sort((a, b) => a.displaySymbol.localeCompare(b.displaySymbol));
                
                return usdtPairs;
            } catch (error) {
                console.error('Error fetching trading pairs:', error);
                return [];
            }
        }

        const updateOrderbook = (orderbook) => {
            const { bids, asks } = orderbook;
            
            if (!bids || !asks || bids.length === 0 || asks.length === 0) {
                console.warn('Empty orderbook data');
                return;
            }
            
            // Process bids: volume = price * quantity, then calculate cumulative
            // Bids should be sorted descending (highest price first, closest to mid)
            const sortedBids = [...bids].sort((a, b) => b[0] - a[0]);
            const bidData = sortedBids
                .map((d) => ({ price: d[0], volume: d[0] * d[1] }));
            
            // Calculate cumulative volume for bids (from highest to lowest price)
            // Start from the highest bid (closest to mid) and accumulate downward
            let cumVolume = 0;
            bidData.forEach((d) => {
                cumVolume += d.volume;
                d.cumVolume = cumVolume;
            });
            
            // Process asks: volume = price * quantity, then calculate cumulative
            // Asks should be sorted ascending (lowest price first, closest to mid)
            const sortedAsks = [...asks].sort((a, b) => a[0] - b[0]);
            const askData = sortedAsks
                .map((d) => ({ price: d[0], volume: d[0] * d[1] }));
            
            // Calculate cumulative volume for asks (from lowest to highest price)
            // Start from the lowest ask (closest to mid) and accumulate upward
            cumVolume = 0;
            askData.forEach((d) => {
                cumVolume += d.volume;
                d.cumVolume = cumVolume;
            });
            
            // Store for resize handling
            window.lastOrderbookData = { bids: bidData, asks: askData };
            
            console.log('Updating orderbook:', {
                bidCount: bidData.length,
                askCount: askData.length,
                bidRange: bidData.length > 0 ? [bidData[bidData.length - 1].price.toFixed(2), bidData[0].price.toFixed(2)] : [],
                askRange: askData.length > 0 ? [askData[0].price.toFixed(2), askData[askData.length - 1].price.toFixed(2)] : [],
                bestBid: bidData[0]?.price.toFixed(2),
                bestAsk: askData[0]?.price.toFixed(2)
            });
            
            update({ bids: bidData, asks: askData });
        }

        let wsConnection = null;

        async function updateSymbol(newSymbol, oldSymbol) {
            // Close existing WebSocket
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
            }

            if (newSymbol) {
                const binanceSymbol = formatSymbolForBinance(newSymbol);
                console.log('Fetching orderbook snapshot for:', binanceSymbol);
                
                // Fetch initial snapshot with max depth (5000 levels)
                const snapshot = await fetchOrderbookSnapshot(binanceSymbol, 5000);
                
                if (snapshot.bids.length > 0 && snapshot.asks.length > 0) {
                    const midPrice = 0.5 * (snapshot.bids[0][0] + snapshot.asks[0][0]);
                    const bpsWidth = Number(window.orderbookRange) || 0.01;
                    const minPrice = (1 - bpsWidth) * midPrice;
                    const maxPrice = (1 + bpsWidth) * midPrice;
                    
                    console.log('Snapshot received:', {
                        bidCount: snapshot.bids.length,
                        askCount: snapshot.asks.length,
                        bidRange: [snapshot.bids[snapshot.bids.length - 1][0].toFixed(2), snapshot.bids[0][0].toFixed(2)],
                        askRange: [snapshot.asks[0][0].toFixed(2), snapshot.asks[snapshot.asks.length - 1][0].toFixed(2)],
                        midPrice: midPrice.toFixed(2),
                        displayRange: [minPrice.toFixed(2), maxPrice.toFixed(2)],
                        bidsInRange: snapshot.bids.filter(b => b[0] >= minPrice && b[0] <= midPrice).length,
                        asksInRange: snapshot.asks.filter(a => a[0] >= midPrice && a[0] <= maxPrice).length
                    });
                    
                    // Update with initial snapshot
                    updateOrderbook(snapshot);
                    
                    // Set up WebSocket for real-time updates
                    // The WebSocket will update the orderbook, but we keep the full snapshot
                    wsConnection = createOrderbookWebSocket(binanceSymbol, (orderbook) => {
                        if (window.orderbookSymbol === newSymbol) {
                            // Merge WebSocket updates with the full snapshot
                            // For now, just use the WebSocket data (it has the latest 20 levels)
                            // In a production system, you'd merge this with the full snapshot
                            updateOrderbook(orderbook);
                        }
                    }, snapshot);
                } else {
                    console.error('Empty snapshot received');
                }
            }
        }

        window.orderbookSymbol = 'BTC/USDT';
        window.orderbookRange = document.getElementById("range-select").value || '0.01';
        console.log('Initializing orderbook:', window.orderbookSymbol, window.orderbookRange);
        
        // Initialize: start orderbook stream for BTC/USDT
        updateSymbol(window.orderbookSymbol);
        window.onclick = async (event) => {
            const target = event.target;

            console.log(target.tagName, target.id);
            const id = target.id;
            if (!id) return;
            
            if (id == "symbol-select") {
                const oldSymbol = window.orderbookSymbol;
                window.orderbookSymbol = document.getElementById("symbol-select").value;
                console.log(window.orderbookSymbol);
                updateSymbol(window.orderbookSymbol, oldSymbol);
            }
            if (id == "range-select") {
                window.orderbookRange = document.getElementById("range-select").value;
                // Trigger update to redraw with new range
                if (window.lastOrderbookData) {
                    update(window.lastOrderbookData);
                }
            }
        }
    </script>
</body>

</html>