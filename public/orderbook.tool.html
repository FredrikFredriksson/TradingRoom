<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Realtime Order Book Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap');
        
        :root {
            --bg-primary: #050a12;
            --bg-secondary: #080e1a;
            --bg-elevated: #0f1a2e;
            --bg-hover: #131f35;
            --accent-primary: #22d3ee;
            --accent-blue: #38bdf8;
            --accent-emerald: #2dd4bf;
            --accent-emerald-bright: #5eead4;
            --color-danger: #f43f5e;
            --color-danger-bright: #fb7185;
            --text-primary: #f0f9ff;
            --text-secondary: #bae6fd;
            --text-muted: #94a3b8;
            --border-subtle: rgba(34, 211, 238, 0.08);
            --border-default: rgba(34, 211, 238, 0.12);
            --radius-sm: 1px;
            --radius-md: 2px;
            --radius-lg: 3px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: transparent;
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .orderbook-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
        }

        #range-select {
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            padding: 8px 16px;
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
        }

        #range-select:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        #range-select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.15);
        }

        #range-select option {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        #symbol-select {
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            padding: 8px 16px;
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            min-width: 140px;
        }

        #symbol-select:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        #symbol-select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.15);
        }

        #symbol-select option {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        #exchange-select {
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            padding: 8px 16px;
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            min-width: 140px;
        }

        #exchange-select:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        #exchange-select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.15);
        }

        #exchange-select option {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        #chart {
            margin: 0;
            padding: 24px;
            width: 100%;
            height: calc(100% - 60px);
            min-height: 400px;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* D3 Chart Styling - Vibrant and Alive */
        .line {
            fill: none;
            stroke-width: 3px;
            transition: stroke-width 0.2s ease;
        }

        .bid-line {
            stroke: var(--accent-emerald);
            filter: drop-shadow(0 0 4px rgba(45, 212, 191, 0.7)) 
                    drop-shadow(0 0 10px rgba(94, 234, 212, 0.35));
        }

        .ask-line {
            stroke: var(--color-danger);
            filter: drop-shadow(0 0 4px rgba(244, 63, 94, 0.7)) 
                    drop-shadow(0 0 10px rgba(251, 113, 133, 0.35));
        }

        .area {
            transition: opacity 0.3s ease;
        }

        .bid-area {
            fill: url(#bidGradient);
            opacity: 0.35;
        }

        .ask-area {
            fill: url(#askGradient);
            opacity: 0.35;
        }
        
        /* Gradient definitions for vibrant colors */
        .gradient-defs {
            position: absolute;
            width: 0;
            height: 0;
        }

        /* Axis styling - Enhanced with colors */
        .orderbook-axis {
            color: var(--text-muted);
        }

        .orderbook-axis text {
            fill: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .orderbook-axis.x-axis text {
            fill: var(--accent-primary);
            opacity: 0.8;
            font-size: min(14px, max(9px, calc(var(--chart-width, 600) / 55)));
        }

        .orderbook-axis.y-axis text {
            fill: var(--accent-blue);
            opacity: 0.9;
            font-size: min(14px, max(9px, calc(var(--chart-height, 400) / 40)));
        }

        .orderbook-axis path,
        .orderbook-axis line {
            stroke: var(--border-subtle);
            stroke-width: 1;
        }

        .orderbook-axis .domain {
            stroke: var(--accent-primary);
            stroke-width: 2;
            opacity: 0.4;
        }

        .orderbook-axis .tick line {
            stroke: var(--accent-primary);
            opacity: 0.2;
        }

        .orderbook-axis.x-axis .tick line {
            stroke: var(--accent-primary);
            opacity: 0.15;
        }

        .orderbook-axis.y-axis .tick line {
            stroke: var(--accent-blue);
            opacity: 0.15;
        }
        
        /* Mid-price line styling */
        .mid-price-line {
            pointer-events: none;
        }
        
        /* Grid lines */
        .grid-lines .grid-line {
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="orderbook-controls">
        <select id="symbol-select" aria-label="Trading pair">
            <option value="BTC/USDT">BTC/USDT</option>
        </select>
        <select id="exchange-select" aria-label="Exchange">
            <option value="Binance" selected>Binance</option>
            <option value="Kraken">Kraken</option>
            <option value="Coinbase">Coinbase</option>
            <option value="HyperLiquid">HyperLiquid</option>
        </select>
        <select id="range-select" value="0.01">
            <option value="0.002">20 bps</option>
            <option value="0.004">40 bps</option>
            <option value="0.006">60 bps</option>
            <option value="0.008">80 bps</option>
            <option value="0.01" selected>100 bps (1%)</option>
            <option value="0.02">200 bps (2%)</option>
            <option value="0.03">300 bps (3%)</option>
            <option value="0.05">5%</option>
            <option value="0.1">10%</option>
        </select>
    </div>

    <!-- Container for the chart -->
    <div id="chart"></div>

    <!-- Include the script -->
    <script>

        // Set up SVG dimensions and margins - make responsive
        // Increased left margin to prevent y-axis labels from being cut
        const margin = { top: 30, right: 40, bottom: 40, left: 85 };
        
        // Get container dimensions
        const chartContainer = document.getElementById('chart');
        const containerWidth = chartContainer.clientWidth || window.innerWidth - 40;
        const containerHeight = chartContainer.clientHeight || 500;
        
        const width = Math.max(containerWidth - margin.left - margin.right, 600);
        const height = Math.max(containerHeight - margin.top - margin.bottom, 400);

        // Append SVG to the chart div - make it responsive
        const svg = d3.select('#chart')
            .append('svg')
            .attr('width', '100%')
            .attr('height', height + margin.top + margin.bottom)
            .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
            .attr('preserveAspectRatio', 'none');
        
        // Add gradient definitions for vibrant colors
        const defs = svg.append('defs');
        
        // Bid gradient (metallic teal green - fits blue theme)
        const bidGradient = defs.append('linearGradient')
            .attr('id', 'bidGradient')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%');
        bidGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#5eead4')
            .attr('stop-opacity', 0.55);
        bidGradient.append('stop')
            .attr('offset', '50%')
            .attr('stop-color', '#2dd4bf')
            .attr('stop-opacity', 0.35);
        bidGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#14b8a6')
            .attr('stop-opacity', 0.15);
        
        // Ask gradient (metallic rose red - fits blue theme)
        const askGradient = defs.append('linearGradient')
            .attr('id', 'askGradient')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%');
        askGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#fb7185')
            .attr('stop-opacity', 0.55);
        askGradient.append('stop')
            .attr('offset', '50%')
            .attr('stop-color', '#f43f5e')
            .attr('stop-opacity', 0.35);
        askGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#e11d48')
            .attr('stop-opacity', 0.15);
        
        // Main chart group
        const chartGroup = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Store dimensions and references for updates
        let chartWidth = width;
        let chartHeight = height;
        chartContainer.style.setProperty('--chart-width', String(chartWidth));
        chartContainer.style.setProperty('--chart-height', String(chartHeight));
        
        // Store SVG reference globally for resize handling
        window.orderbookSvg = svg;

        // Initialize scales - will be updated with actual width
        const x = d3.scaleLinear().range([0, chartWidth]);
        const y = d3.scaleLinear().range([chartHeight, 0]);

        // Initialize axes
        const xAxis = chartGroup.append('g')
            .attr('transform', `translate(0,${chartHeight})`)
            .attr('class', 'orderbook-axis x-axis');
        const yAxis = chartGroup.append('g')
            .attr('class', 'orderbook-axis y-axis');

        // Line generators — step curves for discrete orderbook levels
        const bidLine = d3.line()
            .x(d => x(d.price))
            .y(d => y(d.cumVolume))
            .curve(d3.curveStepAfter);

        const askLine = d3.line()
            .x(d => x(d.price))
            .y(d => y(d.cumVolume))
            .curve(d3.curveStepAfter);

        // Area generators — step curves, fill from baseline to cumulative volume
        const bidArea = d3.area()
            .x(d => x(d.price))
            .y0(chartHeight)
            .y1(d => y(d.cumVolume))
            .curve(d3.curveStepAfter);

        const askArea = d3.area()
            .x(d => x(d.price))
            .y0(chartHeight)
            .y1(d => y(d.cumVolume))
            .curve(d3.curveStepAfter);

        // Paths for bids and asks areas
        const bidAreaPath = chartGroup.append('path')
            .attr('class', 'area bid-area');

        const askAreaPath = chartGroup.append('path')
            .attr('class', 'area ask-area');

        // Paths for bids and asks lines (ensure these are on top of areas)
        const bidPath = chartGroup.append('path')
            .attr('class', 'line bid-line');

        const askPath = chartGroup.append('path')
            .attr('class', 'line ask-line');
        
        // Mid-price indicator line
        const midPriceLine = chartGroup.append('line')
            .attr('class', 'mid-price-line')
            .attr('stroke', 'var(--accent-primary)')
            .attr('stroke-width', 1.5)
            .attr('stroke-dasharray', '4,4')
            .attr('opacity', 0.5)
            .attr('y1', 0)
            .attr('y2', chartHeight);
        
        // Grid lines group
        const gridGroup = chartGroup.append('g')
            .attr('class', 'grid-lines');

        // Function to generate random data (simulate realtime updates)
        function generateData() {
            const midPrice = 100;
            const levels = 25;

            const bids = [];
            const asks = [];

            // Generate bids
            for (let i = levels; i > 0; i--) {
                const price = midPrice - i - Math.random();
                const volume = Math.random() * 10 + 1;
                bids.push({ price, volume });
            }

            // Generate asks
            for (let i = 1; i <= levels; i++) {
                const price = midPrice + i + Math.random();
                const volume = Math.random() * 10 + 1;
                asks.push({ price, volume });
            }

            // Sort bids descending and asks ascending
            bids.sort((a, b) => b.price - a.price);
            asks.sort((a, b) => a.price - b.price);

            // Calculate cumulative volume
            let cumVolume = 0;
            bids.forEach(d => {
                cumVolume += d.volume;
                d.cumVolume = cumVolume;
            });

            cumVolume = 0;
            asks.forEach(d => {
                cumVolume += d.volume;
                d.cumVolume = cumVolume;
            });

            return { bids, asks };
        }

        // Function to update the chart
        // opts.transition: use animation for paths/axes. false = direct attr (no flicker from interrupted transitions during real-time updates)
        function update(data, opts) {
            if (!data || !data.bids || !data.asks || data.bids.length === 0 || data.asks.length === 0) {
                console.warn('Invalid data for update:', data);
                return;
            }
            const useTransition = !opts || opts.transition !== false;
            
            // Update chart dimensions if container size changed
            const newContainerWidth = chartContainer.clientWidth || window.innerWidth - 40;
            const newContainerHeight = chartContainer.clientHeight || 500;
            const newWidth = Math.max(newContainerWidth - margin.left - margin.right, 600);
            const newHeight = Math.max(newContainerHeight - margin.top - margin.bottom, 400);
            
            if (newWidth !== chartWidth || newHeight !== chartHeight) {
                chartWidth = newWidth;
                chartHeight = newHeight;
                
                // Update scales ranges
                x.range([0, chartWidth]);
                y.range([chartHeight, 0]);
                
                // Update area generators
                bidArea.y0(chartHeight);
                askArea.y0(chartHeight);
                
                // Update axes position
                xAxis.attr('transform', `translate(0,${chartHeight})`);
                
                // Update SVG viewBox
                const svgElement = d3.select('#chart svg');
                svgElement.attr('viewBox', `0 0 ${chartWidth + margin.left + margin.right} ${chartHeight + margin.top + margin.bottom}`);
            }
            chartContainer.style.setProperty('--chart-width', String(chartWidth));
            chartContainer.style.setProperty('--chart-height', String(chartHeight));

            // Calculate mid price from best bid and best ask
            const bestBid = data.bids[0];
            const bestAsk = data.asks[0];
            
            if (!bestBid || !bestAsk) {
                console.warn('Missing best bid or ask');
                return;
            }
            
            const midPrice = 0.5 * (bestBid.price + bestAsk.price);
            const bpsWidth = Number(window.orderbookRange) || 0.01;
            const minPrice = (1 - bpsWidth) * midPrice;
            const maxPrice = (1 + bpsWidth) * midPrice;

            // Filter to [minPrice, midPrice] for bids and [midPrice, maxPrice] for asks
            const filteredBids = data.bids.filter(d => d.price >= minPrice && d.price <= midPrice);
            const filteredAsks = data.asks.filter(d => d.price >= midPrice && d.price <= maxPrice);

            if (filteredBids.length === 0 || filteredAsks.length === 0) return;

            // Sort ascending by price for left-to-right drawing (bids: min→mid, asks: mid→max)
            const bidsAsc = [...filteredBids].sort((a, b) => a.price - b.price);
            const asksAsc = [...filteredAsks].sort((a, b) => a.price - b.price);

            // Anchor points so areas reach the x-axis edges when BPS changes
            const lastCumBid = bidsAsc.length ? bidsAsc[0].cumVolume : 0;   // worst bid has max cum
            const lastCumAsk = asksAsc.length ? asksAsc[asksAsc.length - 1].cumVolume : 0;
            const bidPathData = [{ price: minPrice, cumVolume: lastCumBid }, ...bidsAsc];
            const askPathData = [...asksAsc, { price: maxPrice, cumVolume: lastCumAsk }];

            x.domain([minPrice, maxPrice]);
            const maxCumVolume = Math.max(lastCumBid, lastCumAsk, 1);
            // Smooth y-axis max to prevent up/down flicker (Kraken/Coinbase have noisier orderbooks)
            if (typeof smoothedYMax !== 'number' || !isFinite(smoothedYMax) ||
                smoothedYMax / maxCumVolume > 2.5 || smoothedYMax / maxCumVolume < 0.4) {
                smoothedYMax = maxCumVolume; // (re)init on first run or symbol/exchange change
            } else {
                // Expand immediately when data grows; contract slowly (12% new, 88% old) when it shrinks
                smoothedYMax = Math.max(maxCumVolume, 0.12 * maxCumVolume + 0.88 * smoothedYMax);
            }
            y.domain([0, smoothedYMax]);

            // Base step by BPS (for ~$100k asset): ≤40 bps=$50, 60–100 bps=$100, 200 bps=$200, 300 bps–5%=$500, 10%=$1k
            const baseStep = bpsWidth <= 0.004 ? 50 : bpsWidth <= 0.01 ? 100 : bpsWidth <= 0.02 ? 200 : bpsWidth >= 0.1 ? 1000 : 500;
            // Scale by price (ref $100k) and round to a nice 1/2/5 step
            const ref = 100000;
            const raw = baseStep * (Math.max(midPrice, 0.01) / ref);
            const mag = raw <= 0 ? 1e-8 : Math.pow(10, Math.floor(Math.log10(raw)));
            const norm = raw / mag;
            const nice = norm <= 1 ? 1 : norm <= 2 ? 2 : norm <= 5 ? 5 : 10;
            const priceStep = Math.max(mag * nice, 1e-8);
            const xStart = Math.ceil(minPrice / priceStep) * priceStep;
            let xTickValues = [];
            for (let v = xStart; v <= maxPrice; v += priceStep) xTickValues.push(v);
            const maxXTicks = Math.max(3, Math.floor(chartWidth / 90));
            if (xTickValues.length < 2) xTickValues = [];
            else if (xTickValues.length > maxXTicks) {
                const step = Math.ceil(xTickValues.length / maxXTicks);
                xTickValues = xTickValues.filter((_, i) => i % step === 0);
            }

            // Update mid-price line
            const midPriceX = x(midPrice);
            midPriceLine
                .attr('x1', midPriceX)
                .attr('x2', midPriceX)
                .attr('y1', 0)
                .attr('y2', chartHeight);

            // Draw grid lines with blue accent
            gridGroup.selectAll('.grid-line').remove();
            
            // Horizontal grid lines (volume levels)
            const yTickCount = Math.max(3, Math.floor(chartHeight / 50));
            const yTicks = y.ticks(yTickCount);
            yTicks.forEach(tick => {
                gridGroup.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', 0)
                    .attr('x2', chartWidth)
                    .attr('y1', y(tick))
                    .attr('y2', y(tick))
                    .attr('stroke', 'var(--accent-blue)')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.15)
                    .attr('stroke-dasharray', '2,4');
            });
            
            // Vertical grid lines (price levels)
            const xTicks = xTickValues.length >= 2 ? xTickValues : x.ticks(maxXTicks);
            xTicks.forEach(tick => {
                gridGroup.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', x(tick))
                    .attr('x2', x(tick))
                    .attr('y1', 0)
                    .attr('y2', chartHeight)
                    .attr('stroke', 'var(--accent-primary)')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.1)
                    .attr('stroke-dasharray', '2,4');
            });

            const xAxisFn = () => {
                const fmt = priceStep < 0.0001 ? (v) => v.toFixed(6) : priceStep < 0.01 ? (v) => v.toFixed(4) : priceStep < 1 ? (v) => v.toFixed(3) : (v) => d3.format(',.2f')(v);
                const axis = d3.axisBottom(x).tickFormat(fmt);
                if (xTickValues.length >= 2) axis.tickValues(xTickValues);
                else axis.ticks(maxXTicks);
                return axis;
            };
            const yAxisFn = () => d3.axisLeft(y)
                .tickFormat(d => {
                    if (d >= 1e9) return (d / 1e9).toFixed(1) + 'B';
                    if (d >= 1e6) return (d / 1e6).toFixed(1) + 'M';
                    if (d >= 1e3) return (d / 1e3).toFixed(1) + 'K';
                    return d3.format(',.0f')(d);
                })
                .ticks(yTickCount);
            if (useTransition) {
                xAxis.transition().duration(100).ease(d3.easeCubicOut).call(xAxisFn());
                yAxis.transition().duration(100).ease(d3.easeCubicOut).call(yAxisFn());
            } else {
                xAxis.call(xAxisFn());
                yAxis.call(yAxisFn());
            }

            if (useTransition) {
                const t = 80;
                bidAreaPath.datum(bidPathData).transition().duration(t).ease(d3.easeCubicOut).attr('d', bidArea);
                askAreaPath.datum(askPathData).transition().duration(t).ease(d3.easeCubicOut).attr('d', askArea);
                bidPath.datum(bidPathData).transition().duration(t).ease(d3.easeCubicOut).attr('d', bidLine);
                askPath.datum(askPathData).transition().duration(t).ease(d3.easeCubicOut).attr('d', askLine);
            } else {
                bidAreaPath.datum(bidPathData).attr('d', bidArea);
                askAreaPath.datum(askPathData).attr('d', askArea);
                bidPath.datum(bidPathData).attr('d', bidLine);
                askPath.datum(askPathData).attr('d', askLine);
            }
        }

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.lastOrderbookData) update(window.lastOrderbookData);
            }, 250);
        });
        // When embedded in an iframe, the iframe can resize without firing window.resize — observe #chart
        const resizeObserver = new ResizeObserver(() => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.lastOrderbookData) update(window.lastOrderbookData);
            }, 100);
        });
        resizeObserver.observe(chartContainer);
        
        // Initial data load - will be replaced by real data
        // let orderBookData = generateData();
        // update(orderBookData);

        // Simulate realtime updates every 3 seconds
        /*
        setInterval(() => {
            orderBookData = generateData();
            update(orderBookData);
        }, 500);
        */
        // Convert symbol format: BTC/USDT -> BTCUSDT
        function formatSymbolForBinance(displaySymbol) {
            return displaySymbol.replace('/', '').toUpperCase();
        }

        // Fetch orderbook snapshot from Binance
        async function fetchOrderbookSnapshot(symbol, limit = 5000) {
            try {
                // Use max limit (5000) to get as much orderbook data as possible
                const response = await fetch(
                    `https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=${limit}`
                );
                const data = await response.json();
                
                return {
                    bids: data.bids.map(([price, quantity]) => [
                        parseFloat(price),
                        parseFloat(quantity)
                    ]).sort((a, b) => b[0] - a[0]),
                    asks: data.asks.map(([price, quantity]) => [
                        parseFloat(price),
                        parseFloat(quantity)
                    ]).sort((a, b) => a[0] - b[0]),
                    lastUpdateId: data.lastUpdateId,
                };
            } catch (error) {
                console.error(`Error fetching orderbook snapshot for ${symbol}:`, error);
                return { bids: [], asks: [], lastUpdateId: 0 };
            }
        }

        // Binance Diff. Depth @depth@100ms: incremental b/a updates. Merge into full book.
        function createOrderbookWebSocket(symbol, onOrderbookUpdate, initialSnapshot) {
            const ws = new WebSocket(
                `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth@100ms`
            );
            let orderbook = {
                bids: (initialSnapshot.bids || []).map(([p, q]) => [parseFloat(p), parseFloat(q)]).sort((a, b) => b[0] - a[0]),
                asks: (initialSnapshot.asks || []).map(([p, q]) => [parseFloat(p), parseFloat(q)]).sort((a, b) => a[0] - b[0])
            };
            let lastUpdateId = initialSnapshot?.lastUpdateId || 0;

            function applyLevels(side, arr, isBid) {
                if (!arr || !arr.length) return;
                const cmp = (a, b) => isBid ? b[0] - a[0] : a[0] - b[0];
                arr.forEach(([p, q]) => {
                    const price = parseFloat(p);
                    const qty = parseFloat(q);
                    if (qty === 0) {
                        if (isBid) orderbook.bids = orderbook.bids.filter(b => Math.abs(b[0] - price) > 1e-12);
                        else orderbook.asks = orderbook.asks.filter(a => Math.abs(a[0] - price) > 1e-12);
                    } else {
                        const list = isBid ? orderbook.bids : orderbook.asks;
                        const i = list.findIndex(x => Math.abs(x[0] - price) < 1e-12);
                        if (i >= 0) list[i][1] = qty;
                        else { list.push([price, qty]); list.sort(cmp); }
                    }
                });
            }

            ws.onmessage = (e) => {
                try {
                    let data = JSON.parse(e.data);
                    if (data.data) data = data.data;
                    const u = data.u ?? data.lastUpdateId;
                    // Only process depthUpdate; skip if before our snapshot
                    if (data.e !== 'depthUpdate' || (u != null && u <= lastUpdateId)) return;
                    lastUpdateId = u;
                    applyLevels('bids', data.b, true);
                    applyLevels('asks', data.a, false);
                    onOrderbookUpdate({
                        bids: orderbook.bids.map(b => [...b]),
                        asks: orderbook.asks.map(a => [...a]),
                        lastUpdateId: u
                    });
                } catch (err) {
                    console.error('Orderbook WebSocket parse error:', err);
                }
            };
            ws.onerror = () => {};
            ws.onclose = () => {};
            return ws;
        }

        function startBinanceOrderbook(displaySymbol, onOrderbook) {
            let ws = null, cancelled = false;
            (async () => {
                try {
                    const symbol = formatSymbolForBinance(displaySymbol);
                    const snap = await fetchOrderbookSnapshot(symbol, 5000);
                    if (cancelled) return;
                    if (snap.bids.length && snap.asks.length) {
                        lastRender = 0;
                        onOrderbook(snap);
                        ws = createOrderbookWebSocket(symbol, (ob) => { if (!cancelled) onOrderbook(ob); }, snap);
                    }
                } catch (e) { console.error('Binance orderbook error', e); }
            })();
            return () => { cancelled = true; if (ws) try { ws.close(); } catch (_) {} };
        }

        function startKrakenOrderbook(displaySymbol, onOrderbook) {
            const symbol = displaySymbol;
            let ws = null, closed = false;
            const orderbook = { bids: [], asks: [] };
            const DEPTH = 100;

            function applyBids(levels) {
                (levels || []).forEach((l) => {
                    const p = parseFloat(l && l.price), q = parseFloat(l && l.qty);
                    if (!isFinite(p) || !isFinite(q)) return;
                    if (q === 0) {
                        const i = orderbook.bids.findIndex((b) => Math.abs(b[0] - p) < 1e-9);
                        if (i >= 0) orderbook.bids.splice(i, 1);
                    } else {
                        const i = orderbook.bids.findIndex((b) => Math.abs(b[0] - p) < 1e-9);
                        if (i >= 0) orderbook.bids[i][1] = q;
                        else orderbook.bids.push([p, q]);
                    }
                });
                orderbook.bids.sort((a, b) => b[0] - a[0]);
                orderbook.bids.splice(DEPTH);
            }
            function applyAsks(levels) {
                (levels || []).forEach((l) => {
                    const p = parseFloat(l && l.price), q = parseFloat(l && l.qty);
                    if (!isFinite(p) || !isFinite(q)) return;
                    if (q === 0) {
                        const i = orderbook.asks.findIndex((a) => Math.abs(a[0] - p) < 1e-9);
                        if (i >= 0) orderbook.asks.splice(i, 1);
                    } else {
                        const i = orderbook.asks.findIndex((a) => Math.abs(a[0] - p) < 1e-9);
                        if (i >= 0) orderbook.asks[i][1] = q;
                        else orderbook.asks.push([p, q]);
                    }
                });
                orderbook.asks.sort((a, b) => a[0] - b[0]);
                orderbook.asks.splice(DEPTH);
            }
            // Throttle emits to 300ms for stability - Kraken can push many updates/sec; slower = smoother
            let lastEmit = 0, emitTimeout = null;
            const EMIT_THROTTLE_MS = 300;
            function emit(forceImmediate) {
                if (orderbook.bids.length === 0 && orderbook.asks.length === 0) return;
                const now = Date.now();
                if (forceImmediate) {
                    if (emitTimeout) { clearTimeout(emitTimeout); emitTimeout = null; }
                    lastEmit = now;
                    onOrderbook({ bids: orderbook.bids.map((x) => [x[0], x[1]]), asks: orderbook.asks.map((x) => [x[0], x[1]]) });
                    return;
                }
                const elapsed = now - lastEmit;
                if (elapsed >= EMIT_THROTTLE_MS) {
                    if (emitTimeout) { clearTimeout(emitTimeout); emitTimeout = null; }
                    lastEmit = now;
                    onOrderbook({ bids: orderbook.bids.map((x) => [x[0], x[1]]), asks: orderbook.asks.map((x) => [x[0], x[1]]) });
                } else if (!emitTimeout) {
                    emitTimeout = setTimeout(() => {
                        emitTimeout = null;
                        lastEmit = Date.now();
                        onOrderbook({ bids: orderbook.bids.map((x) => [x[0], x[1]]), asks: orderbook.asks.map((x) => [x[0], x[1]]) });
                    }, EMIT_THROTTLE_MS - elapsed);
                }
            }

            function connect() {
                if (closed) return;
                ws = new WebSocket('wss://ws.kraken.com/v2');
                ws.onopen = () => {
                    if (closed) return;
                    ws.send(JSON.stringify({ method: 'subscribe', params: { channel: 'book', symbol: [symbol], depth: DEPTH, snapshot: true }, req_id: 1 }));
                };
                ws.onmessage = (ev) => {
                    if (closed) return;
                    try {
                        const j = JSON.parse(ev.data);
                        if (j.channel !== 'book' || !j.data || !j.data[0]) return;
                        const d = j.data[0];
                        if (d.symbol !== symbol) return;
                        if (j.type === 'snapshot') {
                            orderbook.bids = (d.bids || []).map((l) => {
                                const p = parseFloat(l && l.price), q = parseFloat(l && l.qty);
                                return isFinite(p) && isFinite(q) ? [p, q] : null;
                            }).filter(Boolean).sort((a, b) => b[0] - a[0]).slice(0, DEPTH);
                            orderbook.asks = (d.asks || []).map((l) => {
                                const p = parseFloat(l && l.price), q = parseFloat(l && l.qty);
                                return isFinite(p) && isFinite(q) ? [p, q] : null;
                            }).filter(Boolean).sort((a, b) => a[0] - b[0]).slice(0, DEPTH);
                            emit(true); // snapshot: emit immediately for fast first paint
                        } else {
                            if (d.bids && d.bids.length) applyBids(d.bids);
                            if (d.asks && d.asks.length) applyAsks(d.asks);
                            emit(false); // incremental: throttled to 100ms like Binance
                        }
                    } catch (e) {}
                };
                ws.onerror = () => {};
                ws.onclose = () => { ws = null; if (closed) return; setTimeout(connect, 2000); };
            }
            connect();
            return () => { closed = true; if (emitTimeout) { clearTimeout(emitTimeout); emitTimeout = null; } if (ws) try { ws.close(); } catch (_) {} };
        }

        function startCoinbaseOrderbook(displaySymbol, onOrderbook) {
            const productId = displaySymbol.replace('/USDT', '-USD').replace('/', '-');
            let ws = null, closed = false;
            const orderbook = { bids: [], asks: [] };
            const DEPTH = 100;

            function apply(side, priceLevel, newQty) {
                const isBid = side === 'bid', isAsk = side === 'ask' || side === 'offer';
                if (!isBid && !isAsk) return;
                const p = parseFloat(priceLevel), q = parseFloat(newQty);
                if (!isFinite(p) || !isFinite(q)) return;
                const arr = isBid ? orderbook.bids : orderbook.asks;
                const i = arr.findIndex((x) => Math.abs(x[0] - p) < 1e-9);
                if (q === 0) { if (i >= 0) arr.splice(i, 1); }
                else { if (i >= 0) arr[i][1] = q; else arr.push([p, q]); }
                if (isBid) { orderbook.bids.sort((a, b) => b[0] - a[0]); orderbook.bids.splice(DEPTH); }
                else { orderbook.asks.sort((a, b) => a[0] - b[0]); orderbook.asks.splice(DEPTH); }
            }
            // Throttle emits to 300ms for stability - Coinbase can push many updates/sec; slower = smoother
            let lastEmit = 0, emitTimeout = null;
            const EMIT_THROTTLE_MS = 300;
            function emit() {
                if (orderbook.bids.length === 0 && orderbook.asks.length === 0) return;
                const now = Date.now();
                const elapsed = now - lastEmit;
                if (elapsed >= EMIT_THROTTLE_MS || lastEmit === 0) {
                    if (emitTimeout) { clearTimeout(emitTimeout); emitTimeout = null; }
                    lastEmit = now;
                    onOrderbook({ bids: orderbook.bids.map((x) => [x[0], x[1]]), asks: orderbook.asks.map((x) => [x[0], x[1]]) });
                } else if (!emitTimeout) {
                    emitTimeout = setTimeout(() => {
                        emitTimeout = null;
                        lastEmit = Date.now();
                        onOrderbook({ bids: orderbook.bids.map((x) => [x[0], x[1]]), asks: orderbook.asks.map((x) => [x[0], x[1]]) });
                    }, EMIT_THROTTLE_MS - elapsed);
                }
            }

            function connect() {
                if (closed) return;
                ws = new WebSocket('wss://advanced-trade-ws.coinbase.com');
                ws.onopen = () => {
                    if (closed) return;
                    ws.send(JSON.stringify({ type: 'subscribe', channel: 'level2', product_ids: [productId] }));
                };
                ws.onmessage = (ev) => {
                    if (closed) return;
                    try {
                        const j = JSON.parse(ev.data);
                        if (j.channel !== 'l2_data' && j.channel !== 'level2') return;
                        (j.events || []).forEach((e) => {
                            if (e.product_id !== productId) return;
                            (e.updates || []).forEach((u) => apply(u.side, u.price_level, u.new_quantity));
                        });
                        emit();
                    } catch (e) {}
                };
                ws.onerror = () => {};
                ws.onclose = () => { ws = null; if (closed) return; setTimeout(connect, 2000); };
            }
            connect();
            return () => { closed = true; if (emitTimeout) { clearTimeout(emitTimeout); emitTimeout = null; } if (ws) try { ws.close(); } catch (_) {} };
        }

        function startHyperLiquidOrderbook(displaySymbol, onOrderbook) {
            const coin = (displaySymbol || 'BTC/USDT').split('/')[0] || 'BTC';
            let ws = null, closed = false;
            const orderbook = { bids: [], asks: [] };
            const CAP = 500;

            function toHL(levels) {
                return (levels || []).map((l) => {
                    const p = parseFloat(l && l.px), q = parseFloat(l && l.sz);
                    return (isFinite(p) && isFinite(q)) ? [p, q] : null;
                }).filter(Boolean);
            }
            function emit() {
                if (orderbook.bids.length || orderbook.asks.length)
                    onOrderbook({ bids: orderbook.bids.map((x) => [x[0], x[1]]), asks: orderbook.asks.map((x) => [x[0], x[1]]) });
            }

            // REST l2Book: levels[0]=bids, levels[1]=asks. nSigFigs/nLevels align with WebSocket.
            fetch('https://api.hyperliquid.xyz/info', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ type: 'l2Book', coin: coin, nSigFigs: 5, nLevels: 100 }) })
                .then((r) => r.json())
                .then((d) => {
                    if (closed) return;
                    if (d && Array.isArray(d.levels)) {
                        const b = toHL(d.levels[0]).sort((a, b) => b[0] - a[0]).slice(0, CAP);
                        const a = toHL(d.levels[1]).sort((a, b) => a[0] - b[0]).slice(0, CAP);
                        if (b.length) orderbook.bids = b;
                        if (a.length) orderbook.asks = a;
                        lastRender = 0;
                        emit();
                    }
                })
                .catch(() => {});

            function connect() {
                if (closed) return;
                ws = new WebSocket('wss://api.hyperliquid.xyz/ws');
                ws.onopen = () => {
                    if (closed) return;
                    ws.send(JSON.stringify({ method: 'subscribe', subscription: { type: 'l2Book', coin: coin, nLevels: 100, nSigFigs: 5 } }));
                };
                ws.onmessage = (ev) => {
                    if (closed) return;
                    try {
                        const j = JSON.parse(ev.data);
                        if (j.channel !== 'l2Book' || !j.data || !Array.isArray(j.data.levels)) return;
                        const lev = j.data.levels;
                        // levels[0]=bids, levels[1]=asks. Only overwrite when we have data (avoid wiping with empty).
                        if (lev[0] && lev[0].length) orderbook.bids = toHL(lev[0]).sort((a, b) => b[0] - a[0]).slice(0, CAP);
                        if (lev[1] && lev[1].length) orderbook.asks = toHL(lev[1]).sort((a, b) => a[0] - b[0]).slice(0, CAP);
                        emit();
                    } catch (e) {}
                };
                ws.onerror = () => {};
                ws.onclose = () => { ws = null; if (closed) return; setTimeout(connect, 2000); };
            }
            connect();
            return () => { closed = true; if (ws) try { ws.close(); } catch (_) {} };
        }

        // Fetch trading pairs from Binance
        async function fetchTradingPairs() {
            try {
                const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const data = await response.json();
                
                // Filter for USDT pairs and sort
                const usdtPairs = data.symbols
                    .filter(s => s.symbol.endsWith('USDT') && s.status === 'TRADING')
                    .map(s => ({
                        symbol: s.symbol,
                        displaySymbol: `${s.baseAsset}/${s.quoteAsset}`,
                    }))
                    .sort((a, b) => a.displaySymbol.localeCompare(b.displaySymbol));
                
                return usdtPairs;
            } catch (error) {
                console.error('Error fetching trading pairs:', error);
                return [];
            }
        }

        let lastRender = 0;
        let smoothedYMax = NaN; // Smoothed y-axis max to reduce up/down flicker on Kraken/Coinbase
        const MIN_RENDER_MS = 300; // Slower redraws for stability; Kraken/Coinbase emit throttle 300ms

        function updateOrderbook(orderbook) {
            const { bids, asks } = orderbook;
            if (!bids?.length || !asks?.length) return;

            const sortedBids = [...bids].sort((a, b) => b[0] - a[0]);
            let cum = 0;
            const bidData = sortedBids.map((d) => {
                cum += d[0] * d[1];
                return { price: d[0], volume: d[0] * d[1], cumVolume: cum };
            });

            const sortedAsks = [...asks].sort((a, b) => a[0] - b[0]);
            cum = 0;
            const askData = sortedAsks.map((d) => {
                cum += d[0] * d[1];
                return { price: d[0], volume: d[0] * d[1], cumVolume: cum };
            });

            window.lastOrderbookData = { bids: bidData, asks: askData };
            const now = Date.now();
            if (now - lastRender >= MIN_RENDER_MS) {
                lastRender = now;
                update({ bids: bidData, asks: askData }, { transition: false });
            } else if (!window._obScheduled) {
                window._obScheduled = true;
                setTimeout(() => {
                    window._obScheduled = false;
                    lastRender = Date.now();
                    if (window.lastOrderbookData) update(window.lastOrderbookData, { transition: false });
                }, MIN_RENDER_MS - (now - lastRender));
            }
        }

        let wsConnection = null;

        function startConnection() {
            if (wsConnection) {
                wsConnection();
                wsConnection = null;
                smoothedYMax = NaN; // Reset y-axis when changing symbol/exchange
            }
            const exchange = window.orderbookExchange || 'Binance';
            const symbol = window.orderbookSymbol;
            if (!symbol) return;
            if (exchange === 'Binance') {
                wsConnection = startBinanceOrderbook(symbol, updateOrderbook);
            } else if (exchange === 'Kraken') {
                wsConnection = startKrakenOrderbook(symbol, updateOrderbook);
            } else if (exchange === 'Coinbase') {
                wsConnection = startCoinbaseOrderbook(symbol, updateOrderbook);
            } else if (exchange === 'HyperLiquid') {
                wsConnection = startHyperLiquidOrderbook(symbol, updateOrderbook);
            }
        }

        window.orderbookSymbol = document.getElementById('symbol-select').value || 'BTC/USDT';
        window.orderbookExchange = document.getElementById('exchange-select').value || 'Binance';
        window.orderbookRange = document.getElementById('range-select').value || '0.01';

        document.getElementById('symbol-select').addEventListener('change', function () {
            window.orderbookSymbol = this.value;
            startConnection();
        });

        document.getElementById('exchange-select').addEventListener('change', function () {
            window.orderbookExchange = this.value;
            startConnection();
        });

        document.getElementById('range-select').addEventListener('change', function () {
            window.orderbookRange = this.value;
            if (window.lastOrderbookData) update(window.lastOrderbookData);
        });

        // Populate symbol select from Binance USDT pairs
        fetchTradingPairs().then(pairs => {
            const sel = document.getElementById('symbol-select');
            if (!sel) return;
            const cur = window.orderbookSymbol;
            sel.innerHTML = pairs.map(p => `<option value="${p.displaySymbol}">${p.displaySymbol}</option>`).join('');
            if (pairs.some(p => p.displaySymbol === cur)) sel.value = cur;
        });

        startConnection();
    </script>
</body>

</html>