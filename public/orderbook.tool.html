<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Realtime Order Book Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap');
        
        :root {
            --bg-primary: #050a12;
            --bg-secondary: #080e1a;
            --bg-elevated: #0f1a2e;
            --bg-hover: #131f35;
            --accent-primary: #22d3ee;
            --accent-blue: #38bdf8;
            --accent-emerald: #2dd4bf;
            --accent-emerald-bright: #5eead4;
            --color-danger: #f43f5e;
            --color-danger-bright: #fb7185;
            --text-primary: #f0f9ff;
            --text-secondary: #bae6fd;
            --text-muted: #94a3b8;
            --border-subtle: rgba(34, 211, 238, 0.08);
            --border-default: rgba(34, 211, 238, 0.12);
            --radius-sm: 1px;
            --radius-md: 2px;
            --radius-lg: 3px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: transparent;
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .orderbook-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
        }

        #range-select {
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            padding: 8px 16px;
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
        }

        #range-select:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        #range-select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.15);
        }

        #range-select option {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        #symbol-select {
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            padding: 8px 16px;
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            min-width: 140px;
        }

        #symbol-select:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        #symbol-select:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.15);
        }

        #symbol-select option {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        #chart {
            margin: 0;
            padding: 24px;
            width: 100%;
            height: calc(100% - 60px);
            min-height: 400px;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* D3 Chart Styling - Vibrant and Alive */
        .line {
            fill: none;
            stroke-width: 3px;
            transition: stroke-width 0.2s ease;
        }

        .bid-line {
            stroke: var(--accent-emerald);
            filter: drop-shadow(0 0 4px rgba(45, 212, 191, 0.7)) 
                    drop-shadow(0 0 10px rgba(94, 234, 212, 0.35));
        }

        .ask-line {
            stroke: var(--color-danger);
            filter: drop-shadow(0 0 4px rgba(244, 63, 94, 0.7)) 
                    drop-shadow(0 0 10px rgba(251, 113, 133, 0.35));
        }

        .area {
            transition: opacity 0.3s ease;
        }

        .bid-area {
            fill: url(#bidGradient);
            opacity: 0.35;
        }

        .ask-area {
            fill: url(#askGradient);
            opacity: 0.35;
        }
        
        /* Gradient definitions for vibrant colors */
        .gradient-defs {
            position: absolute;
            width: 0;
            height: 0;
        }

        /* Axis styling - Enhanced with colors */
        .orderbook-axis {
            color: var(--text-muted);
        }

        .orderbook-axis text {
            fill: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .orderbook-axis.x-axis text {
            fill: var(--accent-primary);
            opacity: 0.8;
            font-size: min(14px, max(9px, calc(var(--chart-width, 600) / 55)));
        }

        .orderbook-axis.y-axis text {
            fill: var(--accent-blue);
            opacity: 0.9;
            font-size: min(14px, max(9px, calc(var(--chart-height, 400) / 40)));
        }

        .orderbook-axis path,
        .orderbook-axis line {
            stroke: var(--border-subtle);
            stroke-width: 1;
        }

        .orderbook-axis .domain {
            stroke: var(--accent-primary);
            stroke-width: 2;
            opacity: 0.4;
        }

        .orderbook-axis .tick line {
            stroke: var(--accent-primary);
            opacity: 0.2;
        }

        .orderbook-axis.x-axis .tick line {
            stroke: var(--accent-primary);
            opacity: 0.15;
        }

        .orderbook-axis.y-axis .tick line {
            stroke: var(--accent-blue);
            opacity: 0.15;
        }
        
        /* Mid-price line styling */
        .mid-price-line {
            pointer-events: none;
        }
        
        /* Grid lines */
        .grid-lines .grid-line {
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="orderbook-controls">
        <select id="symbol-select" aria-label="Trading pair">
            <option value="BTC/USDT">BTC/USDT</option>
        </select>
        <select id="range-select" value="0.01">
            <option value="0.002">20 bps</option>
            <option value="0.004">40 bps</option>
            <option value="0.006">60 bps</option>
            <option value="0.008">80 bps</option>
            <option value="0.01" selected>100 bps (1%)</option>
            <option value="0.02">200 bps (2%)</option>
            <option value="0.03">300 bps (3%)</option>
            <option value="0.05">5%</option>
            <option value="0.1">10%</option>
        </select>
    </div>

    <!-- Container for the chart -->
    <div id="chart"></div>

    <!-- Include the script -->
    <script>

        // Set up SVG dimensions and margins - make responsive
        // Increased left margin to prevent y-axis labels from being cut
        const margin = { top: 30, right: 40, bottom: 40, left: 85 };
        
        // Get container dimensions
        const chartContainer = document.getElementById('chart');
        const containerWidth = chartContainer.clientWidth || window.innerWidth - 40;
        const containerHeight = chartContainer.clientHeight || 500;
        
        const width = Math.max(containerWidth - margin.left - margin.right, 600);
        const height = Math.max(containerHeight - margin.top - margin.bottom, 400);

        // Append SVG to the chart div - make it responsive
        const svg = d3.select('#chart')
            .append('svg')
            .attr('width', '100%')
            .attr('height', height + margin.top + margin.bottom)
            .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
            .attr('preserveAspectRatio', 'none');
        
        // Add gradient definitions for vibrant colors
        const defs = svg.append('defs');
        
        // Bid gradient (metallic teal green - fits blue theme)
        const bidGradient = defs.append('linearGradient')
            .attr('id', 'bidGradient')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%');
        bidGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#5eead4')
            .attr('stop-opacity', 0.55);
        bidGradient.append('stop')
            .attr('offset', '50%')
            .attr('stop-color', '#2dd4bf')
            .attr('stop-opacity', 0.35);
        bidGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#14b8a6')
            .attr('stop-opacity', 0.15);
        
        // Ask gradient (metallic rose red - fits blue theme)
        const askGradient = defs.append('linearGradient')
            .attr('id', 'askGradient')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '0%')
            .attr('y2', '100%');
        askGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#fb7185')
            .attr('stop-opacity', 0.55);
        askGradient.append('stop')
            .attr('offset', '50%')
            .attr('stop-color', '#f43f5e')
            .attr('stop-opacity', 0.35);
        askGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#e11d48')
            .attr('stop-opacity', 0.15);
        
        // Main chart group
        const chartGroup = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Store dimensions and references for updates
        let chartWidth = width;
        let chartHeight = height;
        chartContainer.style.setProperty('--chart-width', String(chartWidth));
        chartContainer.style.setProperty('--chart-height', String(chartHeight));
        
        // Store SVG reference globally for resize handling
        window.orderbookSvg = svg;

        // Initialize scales - will be updated with actual width
        const x = d3.scaleLinear().range([0, chartWidth]);
        const y = d3.scaleLinear().range([chartHeight, 0]);

        // Initialize axes
        const xAxis = chartGroup.append('g')
            .attr('transform', `translate(0,${chartHeight})`)
            .attr('class', 'orderbook-axis x-axis');
        const yAxis = chartGroup.append('g')
            .attr('class', 'orderbook-axis y-axis');

        // Line generators — step curves for discrete orderbook levels
        const bidLine = d3.line()
            .x(d => x(d.price))
            .y(d => y(d.cumVolume))
            .curve(d3.curveStepAfter);

        const askLine = d3.line()
            .x(d => x(d.price))
            .y(d => y(d.cumVolume))
            .curve(d3.curveStepAfter);

        // Area generators — step curves, fill from baseline to cumulative volume
        const bidArea = d3.area()
            .x(d => x(d.price))
            .y0(chartHeight)
            .y1(d => y(d.cumVolume))
            .curve(d3.curveStepAfter);

        const askArea = d3.area()
            .x(d => x(d.price))
            .y0(chartHeight)
            .y1(d => y(d.cumVolume))
            .curve(d3.curveStepAfter);

        // Paths for bids and asks areas
        const bidAreaPath = chartGroup.append('path')
            .attr('class', 'area bid-area');

        const askAreaPath = chartGroup.append('path')
            .attr('class', 'area ask-area');

        // Paths for bids and asks lines (ensure these are on top of areas)
        const bidPath = chartGroup.append('path')
            .attr('class', 'line bid-line');

        const askPath = chartGroup.append('path')
            .attr('class', 'line ask-line');
        
        // Mid-price indicator line
        const midPriceLine = chartGroup.append('line')
            .attr('class', 'mid-price-line')
            .attr('stroke', 'var(--accent-primary)')
            .attr('stroke-width', 1.5)
            .attr('stroke-dasharray', '4,4')
            .attr('opacity', 0.5)
            .attr('y1', 0)
            .attr('y2', chartHeight);
        
        // Grid lines group
        const gridGroup = chartGroup.append('g')
            .attr('class', 'grid-lines');

        // Function to generate random data (simulate realtime updates)
        function generateData() {
            const midPrice = 100;
            const levels = 25;

            const bids = [];
            const asks = [];

            // Generate bids
            for (let i = levels; i > 0; i--) {
                const price = midPrice - i - Math.random();
                const volume = Math.random() * 10 + 1;
                bids.push({ price, volume });
            }

            // Generate asks
            for (let i = 1; i <= levels; i++) {
                const price = midPrice + i + Math.random();
                const volume = Math.random() * 10 + 1;
                asks.push({ price, volume });
            }

            // Sort bids descending and asks ascending
            bids.sort((a, b) => b.price - a.price);
            asks.sort((a, b) => a.price - b.price);

            // Calculate cumulative volume
            let cumVolume = 0;
            bids.forEach(d => {
                cumVolume += d.volume;
                d.cumVolume = cumVolume;
            });

            cumVolume = 0;
            asks.forEach(d => {
                cumVolume += d.volume;
                d.cumVolume = cumVolume;
            });

            return { bids, asks };
        }

        // Function to update the chart
        // opts.transition: use animation for paths/axes. false = direct attr (no flicker from interrupted transitions during real-time updates)
        function update(data, opts) {
            if (!data || !data.bids || !data.asks || data.bids.length === 0 || data.asks.length === 0) {
                console.warn('Invalid data for update:', data);
                return;
            }
            const useTransition = !opts || opts.transition !== false;
            
            // Update chart dimensions if container size changed
            const newContainerWidth = chartContainer.clientWidth || window.innerWidth - 40;
            const newContainerHeight = chartContainer.clientHeight || 500;
            const newWidth = Math.max(newContainerWidth - margin.left - margin.right, 600);
            const newHeight = Math.max(newContainerHeight - margin.top - margin.bottom, 400);
            
            if (newWidth !== chartWidth || newHeight !== chartHeight) {
                chartWidth = newWidth;
                chartHeight = newHeight;
                
                // Update scales ranges
                x.range([0, chartWidth]);
                y.range([chartHeight, 0]);
                
                // Update area generators
                bidArea.y0(chartHeight);
                askArea.y0(chartHeight);
                
                // Update axes position
                xAxis.attr('transform', `translate(0,${chartHeight})`);
                
                // Update SVG viewBox
                const svgElement = d3.select('#chart svg');
                svgElement.attr('viewBox', `0 0 ${chartWidth + margin.left + margin.right} ${chartHeight + margin.top + margin.bottom}`);
            }
            chartContainer.style.setProperty('--chart-width', String(chartWidth));
            chartContainer.style.setProperty('--chart-height', String(chartHeight));

            // Calculate mid price from best bid and best ask
            const bestBid = data.bids[0];
            const bestAsk = data.asks[0];
            
            if (!bestBid || !bestAsk) {
                console.warn('Missing best bid or ask');
                return;
            }
            
            const midPrice = 0.5 * (bestBid.price + bestAsk.price);
            const bpsWidth = Number(window.orderbookRange) || 0.01;
            const minPrice = (1 - bpsWidth) * midPrice;
            const maxPrice = (1 + bpsWidth) * midPrice;

            // Filter to [minPrice, midPrice] for bids and [midPrice, maxPrice] for asks
            const filteredBids = data.bids.filter(d => d.price >= minPrice && d.price <= midPrice);
            const filteredAsks = data.asks.filter(d => d.price >= midPrice && d.price <= maxPrice);

            if (filteredBids.length === 0 || filteredAsks.length === 0) return;

            // Sort ascending by price for left-to-right drawing (bids: min→mid, asks: mid→max)
            const bidsAsc = [...filteredBids].sort((a, b) => a.price - b.price);
            const asksAsc = [...filteredAsks].sort((a, b) => a.price - b.price);

            // Anchor points so areas reach the x-axis edges when BPS changes
            const lastCumBid = bidsAsc.length ? bidsAsc[0].cumVolume : 0;   // worst bid has max cum
            const lastCumAsk = asksAsc.length ? asksAsc[asksAsc.length - 1].cumVolume : 0;
            const bidPathData = [{ price: minPrice, cumVolume: lastCumBid }, ...bidsAsc];
            const askPathData = [...asksAsc, { price: maxPrice, cumVolume: lastCumAsk }];

            x.domain([minPrice, maxPrice]);
            const maxCumVolume = Math.max(lastCumBid, lastCumAsk, 1);
            y.domain([0, maxCumVolume]);

            // Base step by BPS (for ~$100k asset): ≤40 bps=$50, 60–100 bps=$100, 200 bps=$200, 300 bps–5%=$500, 10%=$1k
            const baseStep = bpsWidth <= 0.004 ? 50 : bpsWidth <= 0.01 ? 100 : bpsWidth <= 0.02 ? 200 : bpsWidth >= 0.1 ? 1000 : 500;
            // Scale by price (ref $100k) and round to a nice 1/2/5 step
            const ref = 100000;
            const raw = baseStep * (Math.max(midPrice, 0.01) / ref);
            const mag = raw <= 0 ? 1e-8 : Math.pow(10, Math.floor(Math.log10(raw)));
            const norm = raw / mag;
            const nice = norm <= 1 ? 1 : norm <= 2 ? 2 : norm <= 5 ? 5 : 10;
            const priceStep = Math.max(mag * nice, 1e-8);
            const xStart = Math.ceil(minPrice / priceStep) * priceStep;
            let xTickValues = [];
            for (let v = xStart; v <= maxPrice; v += priceStep) xTickValues.push(v);
            const maxXTicks = Math.max(3, Math.floor(chartWidth / 90));
            if (xTickValues.length < 2) xTickValues = [];
            else if (xTickValues.length > maxXTicks) {
                const step = Math.ceil(xTickValues.length / maxXTicks);
                xTickValues = xTickValues.filter((_, i) => i % step === 0);
            }

            // Update mid-price line
            const midPriceX = x(midPrice);
            midPriceLine
                .attr('x1', midPriceX)
                .attr('x2', midPriceX)
                .attr('y1', 0)
                .attr('y2', chartHeight);

            // Draw grid lines with blue accent
            gridGroup.selectAll('.grid-line').remove();
            
            // Horizontal grid lines (volume levels)
            const yTickCount = Math.max(3, Math.floor(chartHeight / 50));
            const yTicks = y.ticks(yTickCount);
            yTicks.forEach(tick => {
                gridGroup.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', 0)
                    .attr('x2', chartWidth)
                    .attr('y1', y(tick))
                    .attr('y2', y(tick))
                    .attr('stroke', 'var(--accent-blue)')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.15)
                    .attr('stroke-dasharray', '2,4');
            });
            
            // Vertical grid lines (price levels)
            const xTicks = xTickValues.length >= 2 ? xTickValues : x.ticks(maxXTicks);
            xTicks.forEach(tick => {
                gridGroup.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', x(tick))
                    .attr('x2', x(tick))
                    .attr('y1', 0)
                    .attr('y2', chartHeight)
                    .attr('stroke', 'var(--accent-primary)')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.1)
                    .attr('stroke-dasharray', '2,4');
            });

            const xAxisFn = () => {
                const fmt = priceStep < 0.0001 ? (v) => v.toFixed(6) : priceStep < 0.01 ? (v) => v.toFixed(4) : priceStep < 1 ? (v) => v.toFixed(3) : (v) => d3.format(',.2f')(v);
                const axis = d3.axisBottom(x).tickFormat(fmt);
                if (xTickValues.length >= 2) axis.tickValues(xTickValues);
                else axis.ticks(maxXTicks);
                return axis;
            };
            const yAxisFn = () => d3.axisLeft(y)
                .tickFormat(d => {
                    if (d >= 1e9) return (d / 1e9).toFixed(1) + 'B';
                    if (d >= 1e6) return (d / 1e6).toFixed(1) + 'M';
                    if (d >= 1e3) return (d / 1e3).toFixed(1) + 'K';
                    return d3.format(',.0f')(d);
                })
                .ticks(yTickCount);
            if (useTransition) {
                xAxis.transition().duration(100).ease(d3.easeCubicOut).call(xAxisFn());
                yAxis.transition().duration(100).ease(d3.easeCubicOut).call(yAxisFn());
            } else {
                xAxis.call(xAxisFn());
                yAxis.call(yAxisFn());
            }

            if (useTransition) {
                const t = 80;
                bidAreaPath.datum(bidPathData).transition().duration(t).ease(d3.easeCubicOut).attr('d', bidArea);
                askAreaPath.datum(askPathData).transition().duration(t).ease(d3.easeCubicOut).attr('d', askArea);
                bidPath.datum(bidPathData).transition().duration(t).ease(d3.easeCubicOut).attr('d', bidLine);
                askPath.datum(askPathData).transition().duration(t).ease(d3.easeCubicOut).attr('d', askLine);
            } else {
                bidAreaPath.datum(bidPathData).attr('d', bidArea);
                askAreaPath.datum(askPathData).attr('d', askArea);
                bidPath.datum(bidPathData).attr('d', bidLine);
                askPath.datum(askPathData).attr('d', askLine);
            }
        }

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.lastOrderbookData) update(window.lastOrderbookData);
            }, 250);
        });
        // When embedded in an iframe, the iframe can resize without firing window.resize — observe #chart
        const resizeObserver = new ResizeObserver(() => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.lastOrderbookData) update(window.lastOrderbookData);
            }, 100);
        });
        resizeObserver.observe(chartContainer);
        
        // Initial data load - will be replaced by real data
        // let orderBookData = generateData();
        // update(orderBookData);

        // Simulate realtime updates every 3 seconds
        /*
        setInterval(() => {
            orderBookData = generateData();
            update(orderBookData);
        }, 500);
        */
        // Convert symbol format: BTC/USDT -> BTCUSDT
        function formatSymbolForBinance(displaySymbol) {
            return displaySymbol.replace('/', '').toUpperCase();
        }

        // Fetch orderbook snapshot from Binance
        async function fetchOrderbookSnapshot(symbol, limit = 5000) {
            try {
                // Use max limit (5000) to get as much orderbook data as possible
                const response = await fetch(
                    `https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=${limit}`
                );
                const data = await response.json();
                
                return {
                    bids: data.bids.map(([price, quantity]) => [
                        parseFloat(price),
                        parseFloat(quantity)
                    ]).sort((a, b) => b[0] - a[0]),
                    asks: data.asks.map(([price, quantity]) => [
                        parseFloat(price),
                        parseFloat(quantity)
                    ]).sort((a, b) => a[0] - b[0]),
                    lastUpdateId: data.lastUpdateId,
                };
            } catch (error) {
                console.error(`Error fetching orderbook snapshot for ${symbol}:`, error);
                return { bids: [], asks: [], lastUpdateId: 0 };
            }
        }

        // Binance Diff. Depth @depth@100ms: incremental b/a updates. Merge into full book.
        function createOrderbookWebSocket(symbol, onOrderbookUpdate, initialSnapshot) {
            const ws = new WebSocket(
                `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth@100ms`
            );
            let orderbook = {
                bids: (initialSnapshot.bids || []).map(([p, q]) => [parseFloat(p), parseFloat(q)]).sort((a, b) => b[0] - a[0]),
                asks: (initialSnapshot.asks || []).map(([p, q]) => [parseFloat(p), parseFloat(q)]).sort((a, b) => a[0] - b[0])
            };
            let lastUpdateId = initialSnapshot?.lastUpdateId || 0;

            function applyLevels(side, arr, isBid) {
                if (!arr || !arr.length) return;
                const cmp = (a, b) => isBid ? b[0] - a[0] : a[0] - b[0];
                arr.forEach(([p, q]) => {
                    const price = parseFloat(p);
                    const qty = parseFloat(q);
                    if (qty === 0) {
                        if (isBid) orderbook.bids = orderbook.bids.filter(b => Math.abs(b[0] - price) > 1e-12);
                        else orderbook.asks = orderbook.asks.filter(a => Math.abs(a[0] - price) > 1e-12);
                    } else {
                        const list = isBid ? orderbook.bids : orderbook.asks;
                        const i = list.findIndex(x => Math.abs(x[0] - price) < 1e-12);
                        if (i >= 0) list[i][1] = qty;
                        else { list.push([price, qty]); list.sort(cmp); }
                    }
                });
            }

            ws.onmessage = (e) => {
                try {
                    let data = JSON.parse(e.data);
                    if (data.data) data = data.data;
                    const u = data.u ?? data.lastUpdateId;
                    // Only process depthUpdate; skip if before our snapshot
                    if (data.e !== 'depthUpdate' || (u != null && u <= lastUpdateId)) return;
                    lastUpdateId = u;
                    applyLevels('bids', data.b, true);
                    applyLevels('asks', data.a, false);
                    onOrderbookUpdate({
                        bids: orderbook.bids.map(b => [...b]),
                        asks: orderbook.asks.map(a => [...a]),
                        lastUpdateId: u
                    });
                } catch (err) {
                    console.error('Orderbook WebSocket parse error:', err);
                }
            };
            ws.onerror = () => {};
            ws.onclose = () => {};
            return ws;
        }

        // Fetch trading pairs from Binance
        async function fetchTradingPairs() {
            try {
                const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const data = await response.json();
                
                // Filter for USDT pairs and sort
                const usdtPairs = data.symbols
                    .filter(s => s.symbol.endsWith('USDT') && s.status === 'TRADING')
                    .map(s => ({
                        symbol: s.symbol,
                        displaySymbol: `${s.baseAsset}/${s.quoteAsset}`,
                    }))
                    .sort((a, b) => a.displaySymbol.localeCompare(b.displaySymbol));
                
                return usdtPairs;
            } catch (error) {
                console.error('Error fetching trading pairs:', error);
                return [];
            }
        }

        let lastRender = 0;
        const MIN_RENDER_MS = 50;

        function updateOrderbook(orderbook) {
            const { bids, asks } = orderbook;
            if (!bids?.length || !asks?.length) return;

            const sortedBids = [...bids].sort((a, b) => b[0] - a[0]);
            let cum = 0;
            const bidData = sortedBids.map((d) => {
                cum += d[0] * d[1];
                return { price: d[0], volume: d[0] * d[1], cumVolume: cum };
            });

            const sortedAsks = [...asks].sort((a, b) => a[0] - b[0]);
            cum = 0;
            const askData = sortedAsks.map((d) => {
                cum += d[0] * d[1];
                return { price: d[0], volume: d[0] * d[1], cumVolume: cum };
            });

            window.lastOrderbookData = { bids: bidData, asks: askData };
            const now = Date.now();
            if (now - lastRender >= MIN_RENDER_MS) {
                lastRender = now;
                update({ bids: bidData, asks: askData }, { transition: false });
            } else if (!window._obScheduled) {
                window._obScheduled = true;
                setTimeout(() => {
                    window._obScheduled = false;
                    lastRender = Date.now();
                    if (window.lastOrderbookData) update(window.lastOrderbookData, { transition: false });
                }, MIN_RENDER_MS - (now - lastRender));
            }
        }

        let wsConnection = null;

        async function updateSymbol(newSymbol, oldSymbol) {
            // Close existing WebSocket
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
            }

            if (newSymbol) {
                const binanceSymbol = formatSymbolForBinance(newSymbol);
                const snapshot = await fetchOrderbookSnapshot(binanceSymbol, 5000);
                
                if (snapshot.bids.length > 0 && snapshot.asks.length > 0) {
                    lastRender = 0;
                    updateOrderbook(snapshot);
                    
                    // Set up WebSocket for real-time updates
                    // The WebSocket will update the orderbook, but we keep the full snapshot
                    wsConnection = createOrderbookWebSocket(binanceSymbol, (orderbook) => {
                        if (window.orderbookSymbol === newSymbol) {
                            // Merge WebSocket updates with the full snapshot
                            // For now, just use the WebSocket data (it has the latest 20 levels)
                            // In a production system, you'd merge this with the full snapshot
                            updateOrderbook(orderbook);
                        }
                    }, snapshot);
                } else {
                    console.error('Empty snapshot received');
                }
            }
        }

        window.orderbookSymbol = document.getElementById('symbol-select').value || 'BTC/USDT';
        window.orderbookRange = document.getElementById('range-select').value || '0.01';

        document.getElementById('symbol-select').addEventListener('change', function () {
            const oldSymbol = window.orderbookSymbol;
            window.orderbookSymbol = this.value;
            updateSymbol(window.orderbookSymbol, oldSymbol);
        });

        document.getElementById('range-select').addEventListener('change', function () {
            window.orderbookRange = this.value;
            if (window.lastOrderbookData) update(window.lastOrderbookData);
        });

        // Populate symbol select from Binance USDT pairs
        fetchTradingPairs().then(pairs => {
            const sel = document.getElementById('symbol-select');
            const cur = window.orderbookSymbol;
            sel.innerHTML = pairs.map(p => `<option value="${p.displaySymbol}">${p.displaySymbol}</option>`).join('');
            if (pairs.some(p => p.displaySymbol === cur)) sel.value = cur;
        });

        updateSymbol(window.orderbookSymbol);
    </script>
</body>

</html>