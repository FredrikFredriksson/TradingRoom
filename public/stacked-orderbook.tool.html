<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Stacked Realtime Order Book Visualization with Individual Bid/Ask Lines</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Design system: dark blue theme (matches TradingRoom) */
        html, body { height: 100%; margin: 0; padding: 0; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f1a2e;
            color: #f0f9ff;
            display: flex;
            flex-direction: column;
            -webkit-font-smoothing: antialiased;
        }

        #controls {
            flex-shrink: 0;
            margin: 8px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #controls label {
            color: #f0f9ff;
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
        }

        #symbol {
            background: #0c1524;
            color: #f0f9ff;
            border: 1px solid rgba(34, 211, 238, 0.12);
            border-radius: 2px;
            padding: 6px 12px;
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'JetBrains Mono', monospace;
        }

        #symbol:hover, #symbol:focus {
            border-color: rgba(34, 211, 238, 0.2);
            outline: none;
        }

        #symbol option {
            background: #0c1524;
            color: #f0f9ff;
        }

        #status {
            color: #94a3b8;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
        }

        #chart {
            flex: 1;
            min-height: 180px;
            margin: 0 12px 12px;
            overflow: hidden;
        }

        #chart svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* D3 axis – match Orderbook tool: JetBrains Mono, 11px, accent colors */
        .orderbook-axis text {
            fill: #bae6fd;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }
        .orderbook-axis.x-axis text { fill: #22d3ee; opacity: 0.8; }
        .orderbook-axis.y-axis text { fill: #38bdf8; opacity: 0.9; }
        .orderbook-axis path, .orderbook-axis line { stroke: rgba(34, 211, 238, 0.08); stroke-width: 1; }
        .orderbook-axis .domain { stroke: #22d3ee; stroke-width: 2; opacity: 0.4; }
        .orderbook-axis .tick line { opacity: 0.15; }
        .orderbook-axis.x-axis .tick line { stroke: #22d3ee; }
        .orderbook-axis.y-axis .tick line { stroke: #38bdf8; }

        .line { fill: none; stroke-width: 1.5px; }
        .area { stroke: none; opacity: 0.28; }

        .legend rect { stroke: rgba(34, 211, 238, 0.2); stroke-width: 1px; }
        .legend text {
            fill: #bae6fd;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
    </style>
</head>

<body>
    <!-- Controls -->
    <div id="controls">
        <label for="symbol">Symbol:</label>
        <select id="symbol">
            <option value="BTC/USDT">BTC/USDT</option>
            <option value="ETH/USDT">ETH/USDT</option>
            <option value="SOL/USDT">SOL/USDT</option>
        </select>
        <span id="status">Live: Binance, Kraken, Coinbase</span>
    </div>
    <!-- Container for the chart -->
    <div id="chart" class="svg-container"></div>

    <script>
        // --- Multi-Exchange Orderbook (Binance, Kraken, Coinbase — free, no API keys) ---
        (function () {
            var LEVELS = 50;
            function toChartFormat(bids, asks, levels) {
                levels = levels || LEVELS;
                function row(p, v) { var a = parseFloat(p), b = parseFloat(v); return isFinite(a) && isFinite(b) && b > 0 ? { price: a, volume: b } : null; }
                var b = (bids || []).map(function (x) { return row(x[0], x[1]); }).filter(Boolean).sort(function (a, b) { return b.price - a.price; }).slice(0, levels);
                var a = (asks || []).map(function (x) { return row(x[0], x[1]); }).filter(Boolean).sort(function (a, b) { return a.price - b.price; }).slice(0, levels);
                if (b.length === 0 && a.length === 0) return { bids: [], asks: [] };
                var firstBid = b.length ? 1.000001 * b[0].price : 0, firstAsk = a.length ? 0.999999 * a[0].price : 0;
                b.splice(0, 0, { price: firstBid, volume: 0 }); a.splice(0, 0, { price: firstAsk, volume: 0 });
                var cum = 0; b.forEach(function (d) { cum += d.volume; d.cumVolume = cum; }); cum = 0; a.forEach(function (d) { cum += d.volume; d.cumVolume = cum; });
                return { bids: b, asks: a };
            }
            function startBinance(displaySymbol, onBook) {
                var symbol = displaySymbol.replace('/', '').toUpperCase(), ws = null, orderbook = { bids: [], asks: [] }, lastUpdateId = 0, snapshotDone = false, closed = false, CAP = 120;
                function emit() { var r = toChartFormat(orderbook.bids, orderbook.asks); if (r.bids.length || r.asks.length) onBook('Binance', r); }
                function run() {
                    if (closed) return;
                    snapshotDone = false;
                    fetch('https://api.binance.com/api/v3/depth?symbol=' + symbol + '&limit=100').then(function (r) { return r.json(); }).then(function (data) {
                        if (closed) return;
                        orderbook = { bids: (data.bids || []).map(function (x) { var a = parseFloat(x[0]), b = parseFloat(x[1]); return isFinite(a) && isFinite(b) ? [a, b] : null; }).filter(Boolean).sort(function (a, b) { return b[0] - a[0]; }), asks: (data.asks || []).map(function (x) { var a = parseFloat(x[0]), b = parseFloat(x[1]); return isFinite(a) && isFinite(b) ? [a, b] : null; }).filter(Boolean).sort(function (a, b) { return a[0] - b[0]; }) };
                        lastUpdateId = data.lastUpdateId || 0; snapshotDone = true; emit();
                    }).catch(function () { snapshotDone = true; });
                    ws = new WebSocket('wss://stream.binance.com:9443/ws/' + symbol.toLowerCase() + '@depth@100ms');
                    ws.onmessage = function (ev) {
                        if (!snapshotDone || closed) return;
                        try {
                            var d = JSON.parse(ev.data);
                            if (d.e !== 'depthUpdate' || d.u == null) return;
                            if (d.u <= lastUpdateId) return;
                            lastUpdateId = d.u;
                            (d.b || []).forEach(function (x) { var p = parseFloat(x[0]), q = parseFloat(x[1]); if (!isFinite(p) || !isFinite(q)) return; if (q === 0) orderbook.bids = orderbook.bids.filter(function (b) { return Math.abs(b[0] - p) > 1e-9; }); else { var i = orderbook.bids.findIndex(function (b) { return Math.abs(b[0] - p) < 1e-9; }); if (i >= 0) orderbook.bids[i][1] = q; else orderbook.bids.push([p, q]); } });
                            (d.a || []).forEach(function (x) { var p = parseFloat(x[0]), q = parseFloat(x[1]); if (!isFinite(p) || !isFinite(q)) return; if (q === 0) orderbook.asks = orderbook.asks.filter(function (a) { return Math.abs(a[0] - p) > 1e-9; }); else { var i = orderbook.asks.findIndex(function (a) { return Math.abs(a[0] - p) < 1e-9; }); if (i >= 0) orderbook.asks[i][1] = q; else orderbook.asks.push([p, q]); } });
                            orderbook.bids.sort(function (a, b) { return b[0] - a[0]; }); orderbook.asks.sort(function (a, b) { return a[0] - b[0]; }); orderbook.bids = orderbook.bids.slice(0, CAP); orderbook.asks = orderbook.asks.slice(0, CAP); emit();
                        } catch (e) {}
                    };
                    ws.onerror = function () {};
                    ws.onclose = function () { if (closed) return; ws = null; setTimeout(run, 2000); };
                }
                run();
                return function () { closed = true; try { if (ws) ws.close(); } catch (_) {} };
            }
            function startKraken(displaySymbol, onBook) {
                var symbol = displaySymbol, ws = null, orderbook = { bids: [], asks: [] }, DEPTH = 100, closed = false;
                function safe(v) { var n = parseFloat(v); return isFinite(n) ? n : null; }
                function applyBids(levels) { (levels || []).forEach(function (l) { var p = safe(l && l.price), q = safe(l && l.qty); if (p == null || q == null) return; if (q === 0) { var i = orderbook.bids.findIndex(function (b) { return Math.abs(b[0] - p) < 1e-9; }); if (i >= 0) orderbook.bids.splice(i, 1); } else { var i = orderbook.bids.findIndex(function (b) { return Math.abs(b[0] - p) < 1e-9; }); if (i >= 0) orderbook.bids[i][1] = q; else orderbook.bids.push([p, q]); } }); orderbook.bids.sort(function (a, b) { return b[0] - a[0]; }); orderbook.bids.splice(DEPTH); }
                function applyAsks(levels) { (levels || []).forEach(function (l) { var p = safe(l && l.price), q = safe(l && l.qty); if (p == null || q == null) return; if (q === 0) { var i = orderbook.asks.findIndex(function (a) { return Math.abs(a[0] - p) < 1e-9; }); if (i >= 0) orderbook.asks.splice(i, 1); } else { var i = orderbook.asks.findIndex(function (a) { return Math.abs(a[0] - p) < 1e-9; }); if (i >= 0) orderbook.asks[i][1] = q; else orderbook.asks.push([p, q]); } }); orderbook.asks.sort(function (a, b) { return a[0] - b[0]; }); orderbook.asks.splice(DEPTH); }
                function emit() { var r = toChartFormat(orderbook.bids, orderbook.asks); if (r.bids.length || r.asks.length) onBook('Kraken', r); }
                function connect() {
                    if (closed) return;
                    ws = new WebSocket('wss://ws.kraken.com/v2');
                    ws.onopen = function () { if (closed) return; ws.send(JSON.stringify({ method: 'subscribe', params: { channel: 'book', symbol: [symbol], depth: DEPTH, snapshot: true }, req_id: 1 })); };
                    ws.onmessage = function (ev) {
                        if (closed) return;
                        try {
                            var j = JSON.parse(ev.data);
                            if (j.channel !== 'book' || !j.data || !j.data[0]) return;
                            var d = j.data[0]; if (d.symbol !== symbol) return;
                            if (j.type === 'snapshot') { orderbook.bids = (d.bids || []).map(function (l) { var p = safe(l && l.price), q = safe(l && l.qty); return (p != null && q != null) ? [p, q] : null; }).filter(Boolean).sort(function (a, b) { return b[0] - a[0]; }).slice(0, DEPTH); orderbook.asks = (d.asks || []).map(function (l) { var p = safe(l && l.price), q = safe(l && l.qty); return (p != null && q != null) ? [p, q] : null; }).filter(Boolean).sort(function (a, b) { return a[0] - b[0]; }).slice(0, DEPTH); } else { if (d.bids && d.bids.length) applyBids(d.bids); if (d.asks && d.asks.length) applyAsks(d.asks); }
                            emit();
                        } catch (e) {}
                    };
                    ws.onerror = function () {};
                    ws.onclose = function () { ws = null; if (closed) return; setTimeout(connect, 2000); };
                }
                connect();
                return function () { closed = true; try { if (ws) ws.close(); } catch (_) {} };
            }
            function startCoinbase(displaySymbol, onBook) {
                var productId = displaySymbol.replace('/USDT', '-USD').replace('/', '-'), ws = null, orderbook = { bids: [], asks: [] }, DEPTH = 100, closed = false;
                function apply(side, priceLevel, newQty) { var isBid = side === 'bid', isAsk = side === 'ask' || side === 'offer'; if (!isBid && !isAsk) return; var p = parseFloat(priceLevel), q = parseFloat(newQty); if (!isFinite(p) || !isFinite(q)) return; var arr = isBid ? orderbook.bids : orderbook.asks, i = arr.findIndex(function (x) { return Math.abs(x[0] - p) < 1e-9; }); if (q === 0) { if (i >= 0) arr.splice(i, 1); } else { if (i >= 0) arr[i][1] = q; else arr.push([p, q]); } if (isBid) { orderbook.bids.sort(function (a, b) { return b[0] - a[0]; }); orderbook.bids.splice(DEPTH); } else { orderbook.asks.sort(function (a, b) { return a[0] - b[0]; }); orderbook.asks.splice(DEPTH); } }
                function emit() { var r = toChartFormat(orderbook.bids, orderbook.asks); if (r.bids.length || r.asks.length) onBook('Coinbase', r); }
                function connect() {
                    if (closed) return;
                    ws = new WebSocket('wss://advanced-trade-ws.coinbase.com');
                    ws.onopen = function () { if (closed) return; ws.send(JSON.stringify({ type: 'subscribe', channel: 'level2', product_ids: [productId] })); };
                    ws.onmessage = function (ev) {
                        if (closed) return;
                        try {
                            var j = JSON.parse(ev.data);
                            if (j.channel !== 'l2_data' && j.channel !== 'level2') return;
                            (j.events || []).forEach(function (e) { if (e.product_id !== productId) return; (e.updates || []).forEach(function (u) { apply(u.side, u.price_level, u.new_quantity); }); });
                            emit();
                        } catch (e) {}
                    };
                    ws.onerror = function () {};
                    ws.onclose = function () { ws = null; if (closed) return; setTimeout(connect, 2000); };
                }
                connect();
                return function () { closed = true; try { if (ws) ws.close(); } catch (_) {} };
            }
            function startMultiExchangeOrderbook(displaySymbol, onData) {
                var state = { Binance: null, Kraken: null, Coinbase: null }, unsub = [];
                function put(exchange, book) { state[exchange] = book; var list = []; if (state.Binance && (state.Binance.bids.length || state.Binance.asks.length)) list.push({ exchange: 'Binance', bids: state.Binance.bids, asks: state.Binance.asks }); if (state.Kraken && (state.Kraken.bids.length || state.Kraken.asks.length)) list.push({ exchange: 'Kraken', bids: state.Kraken.bids, asks: state.Kraken.asks }); if (state.Coinbase && (state.Coinbase.bids.length || state.Coinbase.asks.length)) list.push({ exchange: 'Coinbase', bids: state.Coinbase.bids, asks: state.Coinbase.asks }); onData(list); }
                unsub.push(startBinance(displaySymbol, function (ex, b) { put(ex, b); }));
                unsub.push(startKraken(displaySymbol, function (ex, b) { put(ex, b); }));
                unsub.push(startCoinbase(displaySymbol, function (ex, b) { put(ex, b); }));
                return function () { unsub.forEach(function (f) { f(); }); };
            }
            window.startMultiExchangeOrderbook = startMultiExchangeOrderbook;
        })();

        // Compact chart size – scales with container (SVG 100% x 100%)
        const margin = { top: 10, right: 92, bottom: 18, left: 42 },
            width = 520 - margin.left - margin.right,
            height = 260 - margin.top - margin.bottom,
            vbW = width + margin.left + margin.right,
            vbH = height + margin.top + margin.bottom;

        const svg = d3.select('#chart')
            .append('svg')
            .attr('viewBox', `0 0 ${vbW} ${vbH}`)
            .attr('preserveAspectRatio', 'xMinYMin meet')
            .attr('width', '100%')
            .attr('height', '100%')
            .classed('svg-content-responsive', true)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        // Initialize scales
        const x = d3.scaleLinear().range([0, width]);
        const y = d3.scaleLinear().range([height, 0]);

        // Initialize axes (classes match Orderbook tool styling)
        const xAxis = svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .attr('class', 'orderbook-axis x-axis');
        const yAxis = svg.append('g')
            .attr('class', 'orderbook-axis y-axis');

        // Design system: cyan / blue / teal (Binance, Kraken, Coinbase)
        const color = d3.scaleOrdinal(['#22d3ee', '#38bdf8', '#2dd4bf']);

        // Function to update the chart
        function update(data) {
            function fin(x) { return isFinite(x); }
            const bidPrices = Array.from(new Set(data.flatMap(function (d) { return (d.bids || []).map(function (p) { return p && p.price; }).filter(fin); }))).sort(function (a, b) { return b - a; });
            const askPrices = Array.from(new Set(data.flatMap(function (d) { return (d.asks || []).map(function (p) { return p && p.price; }).filter(fin); }))).sort(function (a, b) { return a - b; });

            // Build a price level map for bids and asks
            const bidPriceLevels = bidPrices.map(price => ({ price }));
            const askPriceLevels = askPrices.map(price => ({ price }));

            // For each exchange, map cumulative volumes to the price levels (tolerance for float match)
            function near(a, b) { return Math.abs((a || 0) - (b || 0)) < 1e-4; }
            data.forEach(function (orderBook) {
                var lastCumVolumeBid = 0, bidIndex = 0, bids = orderBook.bids || [];
                bidPriceLevels.forEach(function (level) {
                    if (bids[bidIndex] && near(bids[bidIndex].price, level.price)) { lastCumVolumeBid = bids[bidIndex].cumVolume; bidIndex++; }
                    level[orderBook.exchange] = lastCumVolumeBid;
                });
                var lastCumVolumeAsk = 0, askIndex = 0, asks = orderBook.asks || [];
                askPriceLevels.forEach(function (level) {
                    if (asks[askIndex] && near(asks[askIndex].price, level.price)) { lastCumVolumeAsk = asks[askIndex].cumVolume; askIndex++; }
                    level[orderBook.exchange] = lastCumVolumeAsk;
                });
            });

            // Stack the data for bids and asks separately
            const exchanges = data.map(d => d.exchange);
            const stack = d3.stack()
                .keys(exchanges)
                .order(d3.stackOrderNone)
                .offset(d3.stackOffsetNone);

            const stackedBids = stack(bidPriceLevels);
            const stackedAsks = stack(askPriceLevels);

            // Update scales
            const allPrices = bidPrices.concat(askPrices);
            const maxVolume = d3.max([...stackedBids, ...stackedAsks], layer => d3.max(layer, d => d[1]));

            if (allPrices.length === 0) return;
            x.domain([d3.min(allPrices), d3.max(allPrices)]);
            y.domain([0, (maxVolume && isFinite(maxVolume)) ? maxVolume : 1]);

            // Axes: match Orderbook tool number style (JetBrains Mono, K/M/B for y; decimals for x)
            var priceRange = d3.max(allPrices) - d3.min(allPrices) || 1;
            var fmtX = priceRange < 0.0001 ? function (v) { return v.toFixed(6); } : priceRange < 0.01 ? function (v) { return v.toFixed(4); } : priceRange < 1 ? function (v) { return v.toFixed(3); } : function (v) { return d3.format(',.2f')(v); };
            var fmtY = function (d) { return d >= 1e9 ? (d / 1e9).toFixed(1) + 'B' : d >= 1e6 ? (d / 1e6).toFixed(1) + 'M' : d >= 1e3 ? (d / 1e3).toFixed(1) + 'K' : d3.format(',.0f')(d); };
            xAxis.transition().duration(200).ease(d3.easeCubicInOut).call(d3.axisBottom(x).ticks(5).tickFormat(fmtX).tickSizeInner(4).tickSizeOuter(0).tickPadding(2));
            yAxis.transition().duration(200).ease(d3.easeCubicInOut).call(d3.axisLeft(y).ticks(4).tickFormat(fmtY).tickSizeInner(4).tickSizeOuter(0).tickPadding(2));

            // Cancel in-flight transitions before replacing (avoids D3/RAF buildup)
            svg.selectAll('.area, .line').interrupt();
            svg.selectAll('.area').remove();
            svg.selectAll('.line').remove();
            svg.selectAll('.legend').remove();

            // Define area generator
            const areaGenerator = d3.area()
                .x(d => x(d.data.price))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]));

            // Define line generator for individual exchange cumulative volume
            const lineGenerator = d3.line()
                .x(d => x(d.data.price))
                .y(d => y(d[1])); // d[1] is y1 of the current layer

            // Draw stacked bid areas and lines (immediate opacity for reliable render, no fade)
            stackedBids.forEach(function (layer) {
                svg.append('path').datum(layer).attr('class', 'area').attr('d', areaGenerator).style('fill', color(layer.key)).style('opacity', 0.32);
            });
            stackedBids.slice().reverse().forEach(function (layer) {
                svg.append('path').datum(layer).attr('class', 'line').attr('d', lineGenerator).style('stroke', color(layer.key)).style('stroke-width', 1.5).style('opacity', 1);
            });
            stackedAsks.forEach(function (layer) {
                svg.append('path').datum(layer).attr('class', 'area').attr('d', areaGenerator).style('fill', color(layer.key)).style('opacity', 0.32);
            });
            stackedAsks.slice().reverse().forEach(function (layer) {
                svg.append('path').datum(layer).attr('class', 'line').attr('d', lineGenerator).style('stroke', color(layer.key)).style('stroke-width', 1.5).style('opacity', 1);
            });
            // Update legend
            updateLegend(data);
        }

        // Function to update the legend (compact)
        function updateLegend(data) {
            const legend = svg.selectAll('.legend')
                .data(data.map(d => d.exchange))
                .enter()
                .append('g')
                .attr('class', 'legend')
                .attr('transform', (d, i) => `translate(0, ${i * 15})`);

            legend.append('rect')
                .attr('x', width + 56)
                .attr('width', 14)
                .attr('height', 14)
                .style('fill', d => color(d))
                .style('opacity', 0.85);

            legend.append('text')
                .attr('x', width + 50)
                .attr('y', 7)
                .attr('dy', '.35em')
                .style('text-anchor', 'end')
                .style('font-size', '11px')
                .style('font-family', "'JetBrains Mono', monospace")
                .style('font-weight', '600')
                .style('fill', '#bae6fd')
                .text(d => d);
        }

        // Throttle UI updates (allow first paint immediately, then ~4 fps)
        var updateLast = 0, UPDATE_THROTTLE_MS = 260;
        function onDataThrottled(data) {
            if (!data || data.length === 0) return;
            var now = Date.now();
            if (updateLast > 0 && now - updateLast < UPDATE_THROTTLE_MS) return;
            updateLast = now;
            try { update(data); } catch (e) { console.warn('stacked-orderbook update', e); }
        }

        var disconnect = null;

        function startLive(symbol) {
            if (disconnect) { disconnect(); disconnect = null; }
            if (typeof startMultiExchangeOrderbook !== 'function') {
                document.getElementById('status').textContent = 'Error: multi-exchange script not available.';
                return;
            }
            document.getElementById('status').textContent = 'Live: Binance, Kraken, Coinbase — ' + symbol;
            disconnect = startMultiExchangeOrderbook(symbol, onDataThrottled);
        }

        document.getElementById('symbol').addEventListener('change', function () {
            startLive(this.value);
        });

        startLive(document.getElementById('symbol').value);
    </script>
</body>

</html>
